//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package syncmap ;import _c "sync";func (_ga *RuneUint16Map )Length ()int {_ga ._ebc .RLock ();defer _ga ._ebc .RUnlock ();return len (_ga ._cc );};func (_ge *RuneByteMap )Range (f func (_gdc rune ,_ec byte )(_cb bool )){_ge ._fe .RLock ();defer _ge ._fe .RUnlock ();
for _ac ,_acd :=range _ge ._db {if f (_ac ,_acd ){break ;};};};func (_ce *ByteRuneMap )Range (f func (_ba byte ,_g rune )(_ad bool )){_ce ._f .RLock ();defer _ce ._f .RUnlock ();for _gd ,_d :=range _ce ._b {if f (_gd ,_d ){break ;};};};func NewRuneStringMap (m map[rune ]string )*RuneStringMap {return &RuneStringMap {_cde :m }};
func (_ab *RuneByteMap )Write (r rune ,b byte ){_ab ._fe .Lock ();defer _ab ._fe .Unlock ();_ab ._db [r ]=b };func (_bac *RuneSet )Range (f func (_cab rune )(_adc bool )){_bac ._ca .RLock ();defer _bac ._ca .RUnlock ();for _be :=range _bac ._bf {if f (_be ){break ;
};};};func MakeByteRuneMap (length int )*ByteRuneMap {return &ByteRuneMap {_b :make (map[byte ]rune ,length )}};type RuneByteMap struct{_db map[rune ]byte ;_fe _c .RWMutex ;};func NewStringRuneMap (m map[string ]rune )*StringRuneMap {return &StringRuneMap {_fcgf :m }};
func (_fa *StringsMap )Write (g1 ,g2 string ){_fa ._ffa .Lock ();defer _fa ._ffa .Unlock ();_fa ._dea [g1 ]=g2 ;};func NewStringsMap (tuples []StringsTuple )*StringsMap {_dgd :=map[string ]string {};for _ ,_eca :=range tuples {_dgd [_eca .Key ]=_eca .Value ;
};return &StringsMap {_dea :_dgd };};func (_cd *RuneByteMap )Length ()int {_cd ._fe .RLock ();defer _cd ._fe .RUnlock ();return len (_cd ._db )};func (_af *StringRuneMap )Read (g string )(rune ,bool ){_af ._dbf .RLock ();defer _af ._dbf .RUnlock ();_bebb ,_afg :=_af ._fcgf [g ];
return _bebb ,_afg ;};func NewByteRuneMap (m map[byte ]rune )*ByteRuneMap {return &ByteRuneMap {_b :m }};func (_efc *RuneStringMap )Length ()int {_efc ._ff .RLock ();defer _efc ._ff .RUnlock ();return len (_efc ._cde );};func (_eb *RuneSet )Write (r rune ){_eb ._ca .Lock ();
defer _eb ._ca .Unlock ();_eb ._bf [r ]=struct{}{}};func (_gdd *StringRuneMap )Length ()int {_gdd ._dbf .RLock ();defer _gdd ._dbf .RUnlock ();return len (_gdd ._fcgf );};type RuneStringMap struct{_cde map[rune ]string ;_ff _c .RWMutex ;};func (_beb *RuneStringMap )Read (r rune )(string ,bool ){_beb ._ff .RLock ();
defer _beb ._ff .RUnlock ();_abg ,_fcg :=_beb ._cde [r ];return _abg ,_fcg ;};func (_gc *ByteRuneMap )Length ()int {_gc ._f .RLock ();defer _gc ._f .RUnlock ();return len (_gc ._b )};func (_eae *StringRuneMap )Write (g string ,r rune ){_eae ._dbf .Lock ();
defer _eae ._dbf .Unlock ();_eae ._fcgf [g ]=r ;};func (_ae *RuneUint16Map )RangeDelete (f func (_bba rune ,_abga uint16 )(_dbg bool ,_aa bool )){_ae ._ebc .Lock ();defer _ae ._ebc .Unlock ();for _cgba ,_ea :=range _ae ._cc {_de ,_bc :=f (_cgba ,_ea );
if _de {delete (_ae ._cc ,_cgba );};if _bc {break ;};};};func (_dg *RuneUint16Map )Write (r rune ,g uint16 ){_dg ._ebc .Lock ();defer _dg ._ebc .Unlock ();_dg ._cc [r ]=g ;};type RuneUint16Map struct{_cc map[rune ]uint16 ;_ebc _c .RWMutex ;};func MakeRuneByteMap (length int )*RuneByteMap {_ceg :=make (map[rune ]byte ,length );
return &RuneByteMap {_db :_ceg };};func (_cg *ByteRuneMap )Read (b byte )(rune ,bool ){_cg ._f .RLock ();defer _cg ._f .RUnlock ();_fd ,_e :=_cg ._b [b ];return _fd ,_e ;};func (_ebd *RuneUint16Map )Delete (r rune ){_ebd ._ebc .Lock ();defer _ebd ._ebc .Unlock ();
delete (_ebd ._cc ,r );};func (_fb *RuneByteMap )Read (r rune )(byte ,bool ){_fb ._fe .RLock ();defer _fb ._fe .RUnlock ();_ef ,_gdf :=_fb ._db [r ];return _ef ,_gdf ;};type RuneSet struct{_bf map[rune ]struct{};_ca _c .RWMutex ;};func (_bb *RuneStringMap )Write (r rune ,s string ){_bb ._ff .Lock ();
defer _bb ._ff .Unlock ();_bb ._cde [r ]=s ;};type StringsMap struct{_dea map[string ]string ;_ffa _c .RWMutex ;};func (_fc *ByteRuneMap )Write (b byte ,r rune ){_fc ._f .Lock ();defer _fc ._f .Unlock ();_fc ._b [b ]=r };func (_gaa *StringsMap )Range (f func (_cbfa ,_ebdd string )(_ag bool )){_gaa ._ffa .RLock ();
defer _gaa ._ffa .RUnlock ();for _agg ,_gfc :=range _gaa ._dea {if f (_agg ,_gfc ){break ;};};};type ByteRuneMap struct{_b map[byte ]rune ;_f _c .RWMutex ;};type StringRuneMap struct{_fcgf map[string ]rune ;_dbf _c .RWMutex ;};func MakeRuneSet (length int )*RuneSet {return &RuneSet {_bf :make (map[rune ]struct{},length )}};
func (_edc *StringsMap )Copy ()*StringsMap {_edc ._ffa .RLock ();defer _edc ._ffa .RUnlock ();_ee :=map[string ]string {};for _edb ,_fbe :=range _edc ._dea {_ee [_edb ]=_fbe ;};return &StringsMap {_dea :_ee };};func (_ed *RuneUint16Map )Read (r rune )(uint16 ,bool ){_ed ._ebc .RLock ();
defer _ed ._ebc .RUnlock ();_ege ,_ccg :=_ed ._cc [r ];return _ege ,_ccg ;};type StringsTuple struct{Key ,Value string ;};func (_cgb *RuneUint16Map )Range (f func (_df rune ,_fdb uint16 )(_gdg bool )){_cgb ._ebc .RLock ();defer _cgb ._ebc .RUnlock ();for _bg ,_cbc :=range _cgb ._cc {if f (_bg ,_cbc ){break ;
};};};func MakeRuneUint16Map (length int )*RuneUint16Map {return &RuneUint16Map {_cc :make (map[rune ]uint16 ,length )};};func (_ffe *StringsMap )Read (g string )(string ,bool ){_ffe ._ffa .RLock ();defer _ffe ._ffa .RUnlock ();_ecb ,_cfe :=_ffe ._dea [g ];
return _ecb ,_cfe ;};func (_fcd *RuneSet )Length ()int {_fcd ._ca .RLock ();defer _fcd ._ca .RUnlock ();return len (_fcd ._bf )};func (_ceb *RuneSet )Exists (r rune )bool {_ceb ._ca .RLock ();defer _ceb ._ca .RUnlock ();_ ,_fg :=_ceb ._bf [r ];return _fg ;
};func (_gb *RuneStringMap )Range (f func (_bbd rune ,_cee string )(_da bool )){_gb ._ff .RLock ();defer _gb ._ff .RUnlock ();for _bfc ,_cbf :=range _gb ._cde {if f (_bfc ,_cbf ){break ;};};};func (_dgg *StringRuneMap )Range (f func (_gf string ,_bad rune )(_aff bool )){_dgg ._dbf .RLock ();
defer _dgg ._dbf .RUnlock ();for _fdf ,_fba :=range _dgg ._fcgf {if f (_fdf ,_fba ){break ;};};};