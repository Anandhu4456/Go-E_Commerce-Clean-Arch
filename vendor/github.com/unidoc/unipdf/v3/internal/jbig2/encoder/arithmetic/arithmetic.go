//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package arithmetic ;import (_a "bytes";_cd "github.com/unidoc/unipdf/v3/common";_f "github.com/unidoc/unipdf/v3/internal/jbig2/bitmap";_gd "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_c "io";);func (_gbb *Encoder )flush (){_gbb .setBits ();_gbb ._bc <<=_gbb ._gc ;
_gbb .byteOut ();_gbb ._bc <<=_gbb ._gc ;_gbb .byteOut ();_gbb .emit ();if _gbb ._ag !=0xff{_gbb ._ef ++;_gbb ._ag =0xff;_gbb .emit ();};_gbb ._ef ++;_gbb ._ag =0xac;_gbb ._ef ++;_gbb .emit ();};func (_aag *Encoder )setBits (){_aff :=_aag ._bc +uint32 (_aag ._df );
_aag ._bc |=0xffff;if _aag ._bc >=_aff {_aag ._bc -=0x8000;};};func (_egd *Encoder )Reset (){_egd ._df =0x8000;_egd ._bc =0;_egd ._gc =12;_egd ._ef =-1;_egd ._ag =0;_egd ._dg =nil ;_egd ._da =_fc (_agd );};const _cf =0x9b25;func (_cbb *Encoder )codeLPS (_bbe *codingContext ,_dfd uint32 ,_geec uint16 ,_gae byte ){_cbb ._df -=_geec ;
if _cbb ._df < _geec {_cbb ._bc +=uint32 (_geec );}else {_cbb ._df =_geec ;};if _gcc [_gae ]._bcb ==1{_bbe .flipMps (_dfd );};_bbe ._gf [_dfd ]=_gcc [_gae ]._eebg ;_cbb .renormalize ();};func (_daa *Encoder )WriteTo (w _c .Writer )(int64 ,error ){const _cfg ="\u0045n\u0063o\u0064\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f";
var _fca int64 ;for _eeb ,_cgf :=range _daa ._cda {_ga ,_fd :=w .Write (_cgf );if _fd !=nil {return 0,_gd .Wrapf (_fd ,_cfg ,"\u0066\u0061\u0069\u006c\u0065\u0064\u0020\u0061\u0074\u0020\u0069'\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0063h\u0075\u006e\u006b",_eeb );
};_fca +=int64 (_ga );};_daa ._bag =_daa ._bag [:_daa ._bce ];_cdb ,_gca :=w .Write (_daa ._bag );if _gca !=nil {return 0,_gd .Wrap (_gca ,_cfg ,"\u0062u\u0066f\u0065\u0072\u0065\u0064\u0020\u0063\u0068\u0075\u006e\u006b\u0073");};_fca +=int64 (_cdb );
return _fca ,nil ;};func (_dd *Encoder )EncodeInteger (proc Class ,value int )(_cba error ){_cd .Log .Trace ("\u0045\u006eco\u0064\u0065\u0020I\u006e\u0074\u0065\u0067er:\u0027%d\u0027\u0020\u0077\u0069\u0074\u0068\u0020Cl\u0061\u0073\u0073\u003a\u0020\u0027\u0025s\u0027",value ,proc );
if _cba =_dd .encodeInteger (proc ,value );_cba !=nil {return _gd .Wrap (_cba ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u006e\u0074\u0065\u0067\u0065\u0072","");};return nil ;};func (_fbb *Encoder )DataSize ()int {return _fbb .dataSize ()};const (IAAI Class =iota ;
IADH ;IADS ;IADT ;IADW ;IAEX ;IAFS ;IAIT ;IARDH ;IARDW ;IARDX ;IARDY ;IARI ;);func (_gcf *Encoder )EncodeOOB (proc Class )(_cbg error ){_cd .Log .Trace ("E\u006e\u0063\u006f\u0064\u0065\u0020O\u004f\u0042\u0020\u0077\u0069\u0074\u0068\u0020\u0043l\u0061\u0073\u0073:\u0020'\u0025\u0073\u0027",proc );
if _cbg =_gcf .encodeOOB (proc );_cbg !=nil {return _gd .Wrap (_cbg ,"\u0045n\u0063\u006f\u0064\u0065\u004f\u004fB","");};return nil ;};func (_fab *Encoder )lBlock (){if _fab ._ef >=0{_fab .emit ();};_fab ._ef ++;_fab ._ag =uint8 (_fab ._bc >>19);_fab ._bc &=0x7ffff;
_fab ._gc =8;};var _gcc =[]state {{0x5601,1,1,1},{0x3401,2,6,0},{0x1801,3,9,0},{0x0AC1,4,12,0},{0x0521,5,29,0},{0x0221,38,33,0},{0x5601,7,6,1},{0x5401,8,14,0},{0x4801,9,14,0},{0x3801,10,14,0},{0x3001,11,17,0},{0x2401,12,18,0},{0x1C01,13,20,0},{0x1601,29,21,0},{0x5601,15,14,1},{0x5401,16,14,0},{0x5101,17,15,0},{0x4801,18,16,0},{0x3801,19,17,0},{0x3401,20,18,0},{0x3001,21,19,0},{0x2801,22,19,0},{0x2401,23,20,0},{0x2201,24,21,0},{0x1C01,25,22,0},{0x1801,26,23,0},{0x1601,27,24,0},{0x1401,28,25,0},{0x1201,29,26,0},{0x1101,30,27,0},{0x0AC1,31,28,0},{0x09C1,32,29,0},{0x08A1,33,30,0},{0x0521,34,31,0},{0x0441,35,32,0},{0x02A1,36,33,0},{0x0221,37,34,0},{0x0141,38,35,0},{0x0111,39,36,0},{0x0085,40,37,0},{0x0049,41,38,0},{0x0025,42,39,0},{0x0015,43,40,0},{0x0009,44,41,0},{0x0005,45,42,0},{0x0001,45,43,0},{0x5601,46,46,0}};
func (_ea *Encoder )EncodeBitmap (bm *_f .Bitmap ,duplicateLineRemoval bool )error {_cd .Log .Trace ("\u0045n\u0063\u006f\u0064\u0065 \u0042\u0069\u0074\u006d\u0061p\u0020[\u0025d\u0078\u0025\u0064\u005d\u002c\u0020\u0025s",bm .Width ,bm .Height ,bm );
var (_cg ,_dga uint8 ;_efe ,_ecb ,_aga uint16 ;_gg ,_gfc ,_ce byte ;_dgb ,_eag ,_ggg int ;_bf ,_ac []byte ;);for _ff :=0;_ff < bm .Height ;_ff ++{_gg ,_gfc =0,0;if _ff >=2{_gg =bm .Data [(_ff -2)*bm .RowStride ];};if _ff >=1{_gfc =bm .Data [(_ff -1)*bm .RowStride ];
if duplicateLineRemoval {_eag =_ff *bm .RowStride ;_bf =bm .Data [_eag :_eag +bm .RowStride ];_ggg =(_ff -1)*bm .RowStride ;_ac =bm .Data [_ggg :_ggg +bm .RowStride ];if _a .Equal (_bf ,_ac ){_dga =_cg ^1;_cg =1;}else {_dga =_cg ;_cg =0;};};};if duplicateLineRemoval {if _dae :=_ea .encodeBit (_ea ._da ,_cf ,_dga );
_dae !=nil {return _dae ;};if _cg !=0{continue ;};};_ce =bm .Data [_ff *bm .RowStride ];_efe =uint16 (_gg >>5);_ecb =uint16 (_gfc >>4);_gg <<=3;_gfc <<=4;_aga =0;for _dgb =0;_dgb < bm .Width ;_dgb ++{_bge :=uint32 (_efe <<11|_ecb <<4|_aga );_efg :=(_ce &0x80)>>7;
_ggc :=_ea .encodeBit (_ea ._da ,_bge ,_efg );if _ggc !=nil {return _ggc ;};_efe <<=1;_ecb <<=1;_aga <<=1;_efe |=uint16 ((_gg &0x80)>>7);_ecb |=uint16 ((_gfc &0x80)>>7);_aga |=uint16 (_efg );_ggd :=_dgb %8;_aeb :=_dgb /8+1;if _ggd ==4&&_ff >=2{_gg =0;if _aeb < bm .RowStride {_gg =bm .Data [(_ff -2)*bm .RowStride +_aeb ];
};}else {_gg <<=1;};if _ggd ==3&&_ff >=1{_gfc =0;if _aeb < bm .RowStride {_gfc =bm .Data [(_ff -1)*bm .RowStride +_aeb ];};}else {_gfc <<=1;};if _ggd ==7{_ce =0;if _aeb < bm .RowStride {_ce =bm .Data [_ff *bm .RowStride +_aeb ];};}else {_ce <<=1;};_efe &=31;
_ecb &=127;_aga &=15;};};return nil ;};func (_caa *Encoder )emit (){if _caa ._bce ==_edc {_caa ._cda =append (_caa ._cda ,_caa ._bag );_caa ._bag =make ([]byte ,_edc );_caa ._bce =0;};_caa ._bag [_caa ._bce ]=_caa ._ag ;_caa ._bce ++;};type Encoder struct{_bc uint32 ;
_df uint16 ;_gc ,_ag uint8 ;_ef int ;_eca int ;_cda [][]byte ;_bag []byte ;_bce int ;_da *codingContext ;_bg [13]*codingContext ;_dg *codingContext ;};func (_cb Class )String ()string {switch _cb {case IAAI :return "\u0049\u0041\u0041\u0049";case IADH :return "\u0049\u0041\u0044\u0048";
case IADS :return "\u0049\u0041\u0044\u0053";case IADT :return "\u0049\u0041\u0044\u0054";case IADW :return "\u0049\u0041\u0044\u0057";case IAEX :return "\u0049\u0041\u0045\u0058";case IAFS :return "\u0049\u0041\u0046\u0053";case IAIT :return "\u0049\u0041\u0049\u0054";
case IARDH :return "\u0049\u0041\u0052D\u0048";case IARDW :return "\u0049\u0041\u0052D\u0057";case IARDX :return "\u0049\u0041\u0052D\u0058";case IARDY :return "\u0049\u0041\u0052D\u0059";case IARI :return "\u0049\u0041\u0052\u0049";default:return "\u0055N\u004b\u004e\u004f\u0057\u004e";
};};func (_gff *Encoder )Final (){_gff .flush ()};type codingContext struct{_gf []byte ;_ba []byte ;};type state struct{_acd uint16 ;_fgg ,_eebg uint8 ;_bcb uint8 ;};func (_ddc *Encoder )code0 (_ada *codingContext ,_aca uint32 ,_ecd uint16 ,_cfe byte ){if _ada .mps (_aca )==0{_ddc .codeMPS (_ada ,_aca ,_ecd ,_cfe );
}else {_ddc .codeLPS (_ada ,_aca ,_ecd ,_cfe );};};func (_ed *Encoder )EncodeIAID (symbolCodeLength ,value int )(_egf error ){_cd .Log .Trace ("\u0045\u006e\u0063\u006f\u0064\u0065\u0020\u0049A\u0049\u0044\u002e S\u0079\u006d\u0062\u006f\u006c\u0043o\u0064\u0065\u004c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002c \u0056\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",symbolCodeLength ,value );
if _egf =_ed .encodeIAID (symbolCodeLength ,value );_egf !=nil {return _gd .Wrap (_egf ,"\u0045\u006e\u0063\u006f\u0064\u0065\u0049\u0041\u0049\u0044","");};return nil ;};var _ _c .WriterTo =&Encoder {};func (_gfeb *Encoder )encodeBit (_ccb *codingContext ,_gggb uint32 ,_efge uint8 )error {const _af ="\u0045\u006e\u0063\u006f\u0064\u0065\u0072\u002e\u0065\u006e\u0063\u006fd\u0065\u0042\u0069\u0074";
_gfeb ._eca ++;if _gggb >=uint32 (len (_ccb ._gf )){return _gd .Errorf (_af ,"\u0061r\u0069\u0074h\u006d\u0065\u0074i\u0063\u0020\u0065\u006e\u0063\u006f\u0064e\u0072\u0020\u002d\u0020\u0069\u006ev\u0061\u006c\u0069\u0064\u0020\u0063\u0074\u0078\u0020\u006e\u0075m\u0062\u0065\u0072\u003a\u0020\u0027\u0025\u0064\u0027",_gggb );
};_gcd :=_ccb ._gf [_gggb ];_ggf :=_ccb .mps (_gggb );_gbc :=_gcc [_gcd ]._acd ;_cd .Log .Trace ("\u0045\u0043\u003a\u0020\u0025d\u0009\u0020D\u003a\u0020\u0025d\u0009\u0020\u0049\u003a\u0020\u0025d\u0009\u0020\u004dPS\u003a \u0025\u0064\u0009\u0020\u0051\u0045\u003a \u0025\u0030\u0034\u0058\u0009\u0020\u0020\u0041\u003a\u0020\u0025\u0030\u0034\u0058\u0009\u0020\u0043\u003a %\u0030\u0038\u0058\u0009\u0020\u0043\u0054\u003a\u0020\u0025\u0064\u0009\u0020\u0042\u003a\u0020\u0025\u0030\u0032\u0058\u0009\u0020\u0042\u0050\u003a\u0020\u0025\u0064",_gfeb ._eca ,_efge ,_gcd ,_ggf ,_gbc ,_gfeb ._df ,_gfeb ._bc ,_gfeb ._gc ,_gfeb ._ag ,_gfeb ._ef );
if _efge ==0{_gfeb .code0 (_ccb ,_gggb ,_gbc ,_gcd );}else {_gfeb .code1 (_ccb ,_gggb ,_gbc ,_gcd );};return nil ;};func (_cdf *Encoder )Flush (){_cdf ._bce =0;_cdf ._cda =nil ;_cdf ._ef =-1};var _ae =[]intEncRangeS {{0,3,0,2,0,2},{-1,-1,9,4,0,0},{-3,-2,5,3,2,1},{4,19,2,3,4,4},{-19,-4,3,3,4,4},{20,83,6,4,20,6},{-83,-20,7,4,20,6},{84,339,14,5,84,8},{-339,-84,15,5,84,8},{340,4435,30,6,340,12},{-4435,-340,31,6,340,12},{4436,2000000000,62,6,4436,32},{-2000000000,-4436,63,6,4436,32}};
func (_agf *Encoder )Refine (iTemp ,iTarget *_f .Bitmap ,ox ,oy int )error {for _cae :=0;_cae < iTarget .Height ;_cae ++{var _ee int ;_cef :=_cae +oy ;var (_aee ,_bba ,_bfb ,_cbf ,_dc uint16 ;_ecbc ,_dde ,_dgd ,_cc ,_eaga byte ;);if _cef >=1&&(_cef -1)< iTemp .Height {_ecbc =iTemp .Data [(_cef -1)*iTemp .RowStride ];
};if _cef >=0&&_cef < iTemp .Height {_dde =iTemp .Data [_cef *iTemp .RowStride ];};if _cef >=-1&&_cef +1< iTemp .Height {_dgd =iTemp .Data [(_cef +1)*iTemp .RowStride ];};if _cae >=1{_cc =iTarget .Data [(_cae -1)*iTarget .RowStride ];};_eaga =iTarget .Data [_cae *iTarget .RowStride ];
_gb :=uint (6+ox );_aee =uint16 (_ecbc >>_gb );_bba =uint16 (_dde >>_gb );_bfb =uint16 (_dgd >>_gb );_cbf =uint16 (_cc >>6);_gcff :=uint (2-ox );_ecbc <<=_gcff ;_dde <<=_gcff ;_dgd <<=_gcff ;_cc <<=2;for _ee =0;_ee < iTarget .Width ;_ee ++{_eb :=(_aee <<10)|(_bba <<7)|(_bfb <<4)|(_cbf <<1)|_dc ;
_ecbg :=_eaga >>7;_dda :=_agf .encodeBit (_agf ._da ,uint32 (_eb ),_ecbg );if _dda !=nil {return _dda ;};_aee <<=1;_bba <<=1;_bfb <<=1;_cbf <<=1;_aee |=uint16 (_ecbc >>7);_bba |=uint16 (_dde >>7);_bfb |=uint16 (_dgd >>7);_cbf |=uint16 (_cc >>7);_dc =uint16 (_ecbg );
_cgg :=_ee %8;_aea :=_ee /8+1;if _cgg ==5+ox {_ecbc ,_dde ,_dgd =0,0,0;if _aea < iTemp .RowStride &&_cef >=1&&(_cef -1)< iTemp .Height {_ecbc =iTemp .Data [(_cef -1)*iTemp .RowStride +_aea ];};if _aea < iTemp .RowStride &&_cef >=0&&_cef < iTemp .Height {_dde =iTemp .Data [_cef *iTemp .RowStride +_aea ];
};if _aea < iTemp .RowStride &&_cef >=-1&&(_cef +1)< iTemp .Height {_dgd =iTemp .Data [(_cef +1)*iTemp .RowStride +_aea ];};}else {_ecbc <<=1;_dde <<=1;_dgd <<=1;};if _cgg ==5&&_cae >=1{_cc =0;if _aea < iTarget .RowStride {_cc =iTarget .Data [(_cae -1)*iTarget .RowStride +_aea ];
};}else {_cc <<=1;};if _cgg ==7{_eaga =0;if _aea < iTarget .RowStride {_eaga =iTarget .Data [_cae *iTarget .RowStride +_aea ];};}else {_eaga <<=1;};_aee &=7;_bba &=7;_bfb &=7;_cbf &=7;};};return nil ;};func (_ged *Encoder )dataSize ()int {return _edc *len (_ged ._cda )+_ged ._bce };
func (_fcgb *Encoder )renormalize (){for {_fcgb ._df <<=1;_fcgb ._bc <<=1;_fcgb ._gc --;if _fcgb ._gc ==0{_fcgb .byteOut ();};if (_fcgb ._df &0x8000)!=0{break ;};};};func _fc (_d int )*codingContext {return &codingContext {_gf :make ([]byte ,_d ),_ba :make ([]byte ,_d )}};
type Class int ;func (_ebe *Encoder )encodeOOB (_cgc Class )error {_fcg :=_ebe ._bg [_cgc ];_cgb :=_ebe .encodeBit (_fcg ,1,1);if _cgb !=nil {return _cgb ;};_cgb =_ebe .encodeBit (_fcg ,3,0);if _cgb !=nil {return _cgb ;};_cgb =_ebe .encodeBit (_fcg ,6,0);
if _cgb !=nil {return _cgb ;};_cgb =_ebe .encodeBit (_fcg ,12,0);if _cgb !=nil {return _cgb ;};return nil ;};func (_cbe *Encoder )codeMPS (_gab *codingContext ,_edb uint32 ,_gee uint16 ,_adf byte ){_cbe ._df -=_gee ;if _cbe ._df &0x8000!=0{_cbe ._bc +=uint32 (_gee );
return ;};if _cbe ._df < _gee {_cbe ._df =_gee ;}else {_cbe ._bc +=uint32 (_gee );};_gab ._gf [_edb ]=_gcc [_adf ]._fgg ;_cbe .renormalize ();};func (_aa *Encoder )byteOut (){if _aa ._ag ==0xff{_aa .rBlock ();return ;};if _aa ._bc < 0x8000000{_aa .lBlock ();
return ;};_aa ._ag ++;if _aa ._ag !=0xff{_aa .lBlock ();return ;};_aa ._bc &=0x7ffffff;_aa .rBlock ();};func (_ca *codingContext )flipMps (_ec uint32 ){_ca ._ba [_ec ]=1-_ca ._ba [_ec ]};func (_gfe *Encoder )Init (){_gfe ._da =_fc (_agd );_gfe ._df =0x8000;
_gfe ._bc =0;_gfe ._gc =12;_gfe ._ef =-1;_gfe ._ag =0;_gfe ._bce =0;_gfe ._bag =make ([]byte ,_edc );for _eg :=0;_eg < len (_gfe ._bg );_eg ++{_gfe ._bg [_eg ]=_fc (512);};_gfe ._dg =nil ;};func New ()*Encoder {_bb :=&Encoder {};_bb .Init ();return _bb };
type intEncRangeS struct{_e ,_b int ;_ge ,_fe uint8 ;_bd uint16 ;_ab uint8 ;};const (_agd =65536;_edc =20*1024;);func (_beg *Encoder )encodeIAID (_cga ,_aba int )error {if _beg ._dg ==nil {_beg ._dg =_fc (1<<uint (_cga ));};_bef :=uint32 (1<<uint32 (_cga +1))-1;
_aba <<=uint (32-_cga );_gfcb :=uint32 (1);for _fbba :=0;_fbba < _cga ;_fbba ++{_aabb :=_gfcb &_bef ;_fae :=uint8 ((uint32 (_aba )&0x80000000)>>31);if _fg :=_beg .encodeBit (_beg ._dg ,_aabb ,_fae );_fg !=nil {return _fg ;};_gfcb =(_gfcb <<1)|uint32 (_fae );
_aba <<=1;};return nil ;};func (_fa *Encoder )code1 (_bbaf *codingContext ,_daeg uint32 ,_db uint16 ,_fdd byte ){if _bbaf .mps (_daeg )==1{_fa .codeMPS (_bbaf ,_daeg ,_db ,_fdd );}else {_fa .codeLPS (_bbaf ,_daeg ,_db ,_fdd );};};func (_fb *codingContext )mps (_ad uint32 )int {return int (_fb ._ba [_ad ])};
func (_gaeg *Encoder )encodeInteger (_dcb Class ,_eebb int )error {const _aab ="E\u006e\u0063\u006f\u0064er\u002ee\u006e\u0063\u006f\u0064\u0065I\u006e\u0074\u0065\u0067\u0065\u0072";if _eebb > 2000000000||_eebb < -2000000000{return _gd .Errorf (_aab ,"\u0061\u0072\u0069\u0074\u0068\u006d\u0065\u0074i\u0063\u0020\u0065nc\u006f\u0064\u0065\u0072\u0020\u002d \u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0027%\u0064\u0027",_eebb );
};_afa :=_gaeg ._bg [_dcb ];_be :=uint32 (1);var _bcc int ;for ;;_bcc ++{if _ae [_bcc ]._e <=_eebb &&_ae [_bcc ]._b >=_eebb {break ;};};if _eebb < 0{_eebb =-_eebb ;};_eebb -=int (_ae [_bcc ]._bd );_eea :=_ae [_bcc ]._ge ;for _cdd :=uint8 (0);_cdd < _ae [_bcc ]._fe ;
_cdd ++{_cge :=_eea &1;if _fba :=_gaeg .encodeBit (_afa ,_be ,_cge );_fba !=nil {return _gd .Wrap (_fba ,_aab ,"");};_eea >>=1;if _be &0x100> 0{_be =(((_be <<1)|uint32 (_cge ))&0x1ff)|0x100;}else {_be =(_be <<1)|uint32 (_cge );};};_eebb <<=32-_ae [_bcc ]._ab ;
for _bga :=uint8 (0);_bga < _ae [_bcc ]._ab ;_bga ++{_ccba :=uint8 ((uint32 (_eebb )&0x80000000)>>31);if _ege :=_gaeg .encodeBit (_afa ,_be ,_ccba );_ege !=nil {return _gd .Wrap (_ege ,_aab ,"\u006d\u006f\u0076\u0065 \u0064\u0061\u0074\u0061\u0020\u0074\u006f\u0020\u0074\u0068e\u0020t\u006f\u0070\u0020\u006f\u0066\u0020\u0077o\u0072\u0064");
};_eebb <<=1;if _be &0x100!=0{_be =(((_be <<1)|uint32 (_ccba ))&0x1ff)|0x100;}else {_be =(_be <<1)|uint32 (_ccba );};};return nil ;};func (_baa *Encoder )rBlock (){if _baa ._ef >=0{_baa .emit ();};_baa ._ef ++;_baa ._ag =uint8 (_baa ._bc >>20);_baa ._bc &=0xfffff;
_baa ._gc =7;};