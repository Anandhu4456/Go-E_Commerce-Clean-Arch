//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package bitwise ;import (_c "encoding/binary";_d "errors";_e "fmt";_dd "github.com/unidoc/unipdf/v3/common";_fe "github.com/unidoc/unipdf/v3/internal/jbig2/errors";_f "io";);func (_ef *BufferedWriter )SkipBits (skip int )error {if skip ==0{return nil ;
};_eb :=int (_ef ._a )+skip ;if _eb >=0&&_eb < 8{_ef ._a =uint8 (_eb );return nil ;};_eb =int (_ef ._a )+_ef ._bf *8+skip ;if _eb < 0{return _fe .Errorf ("\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073","\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ee :=_eb /8;_cbg :=_eb %8;_ef ._a =uint8 (_cbg );if _gb :=_ee -_ef ._bf ;_gb > 0&&len (_ef ._ec )-1< _ee {if _ef ._a !=0{_gb ++;};_ef .expandIfNeeded (_gb );};_ef ._bf =_ee ;return nil ;};func (_fdb *Reader )Length ()uint64 {return uint64 (_fdb ._efd ._fgc )};
func (_cc *Reader )ReadBits (n byte )(_fbff uint64 ,_ffe error ){if n < _cc ._dff {_eag :=_cc ._dff -n ;_fbff =uint64 (_cc ._ga >>_eag );_cc ._ga &=1<<_eag -1;_cc ._dff =_eag ;return _fbff ,nil ;};if n > _cc ._dff {if _cc ._dff > 0{_fbff =uint64 (_cc ._ga );
n -=_cc ._dff ;};for n >=8{_dbc ,_fgdc :=_cc .readBufferByte ();if _fgdc !=nil {return 0,_fgdc ;};_fbff =_fbff <<8+uint64 (_dbc );n -=8;};if n > 0{if _cc ._ga ,_ffe =_cc .readBufferByte ();_ffe !=nil {return 0,_ffe ;};_egb :=8-n ;_fbff =_fbff <<n +uint64 (_cc ._ga >>_egb );
_cc ._ga &=1<<_egb -1;_cc ._dff =_egb ;}else {_cc ._dff =0;};return _fbff ,nil ;};_cc ._dff =0;return uint64 (_cc ._ga ),nil ;};func (_aad *BufferedWriter )byteCapacity ()int {_ebbf :=len (_aad ._ec )-_aad ._bf ;if _aad ._a !=0{_ebbf --;};return _ebbf ;
};func (_aeb *Reader )Align ()(_cgd byte ){_cgd =_aeb ._dff ;_aeb ._dff =0;return _cgd };type BufferedWriter struct{_ec []byte ;_a uint8 ;_bf int ;_ff bool ;};func (_fd *BufferedWriter )writeByte (_ebbb byte ){switch {case _fd ._a ==0:_fd ._ec [_fd ._bf ]=_ebbb ;
_fd ._bf ++;case _fd ._ff :_fd ._ec [_fd ._bf ]|=_ebbb >>_fd ._a ;_fd ._bf ++;_fd ._ec [_fd ._bf ]=byte (uint16 (_ebbb )<<(8-_fd ._a )&0xff);default:_fd ._ec [_fd ._bf ]|=byte (uint16 (_ebbb )<<_fd ._a &0xff);_fd ._bf ++;_fd ._ec [_fd ._bf ]=_ebbb >>(8-_fd ._a );
};};func (_eef *Reader )readBool ()(_gd bool ,_eged error ){if _eef ._dff ==0{_eef ._ga ,_eged =_eef .readBufferByte ();if _eged !=nil {return false ,_eged ;};_gd =(_eef ._ga &0x80)!=0;_eef ._ga ,_eef ._dff =_eef ._ga &0x7f,7;return _gd ,nil ;};_eef ._dff --;
_gd =(_eef ._ga &(1<<_eef ._dff ))!=0;_eef ._ga &=1<<_eef ._dff -1;return _gd ,nil ;};func (_bb *BufferedWriter )Write (d []byte )(int ,error ){_bb .expandIfNeeded (len (d ));if _bb ._a ==0{return _bb .writeFullBytes (d ),nil ;};return _bb .writeShiftedBytes (d ),nil ;
};var _ BinaryWriter =&BufferedWriter {};func NewReader (data []byte )*Reader {return &Reader {_efd :readerSource {_dfb :data ,_fgc :len (data ),_ege :0}};};func (_cd *Reader )Mark (){_cd ._bfb =_cd ._ggb ;_cd ._ffc =_cd ._dff ;_cd ._bfg =_cd ._ga ;_cd ._cae =_cd ._adcd ;
};func (_fgg *Reader )AbsoluteLength ()uint64 {return uint64 (len (_fgg ._efd ._dfb ))};func (_fed *Reader )RelativePosition ()int64 {return _fed ._ggb };var _ BinaryWriter =&Writer {};func (_ed *BufferedWriter )grow (_gfg int ){if _ed ._ec ==nil &&_gfg < _g {_ed ._ec =make ([]byte ,_gfg ,_g );
return ;};_cbb :=len (_ed ._ec );if _ed ._a !=0{_cbb ++;};_fea :=cap (_ed ._ec );switch {case _gfg <=_fea /2-_cbb :_dd .Log .Trace ("\u005b\u0042\u0075\u0066\u0066\u0065r\u0065\u0064\u0057\u0072\u0069t\u0065\u0072\u005d\u0020\u0067\u0072o\u0077\u0020\u002d\u0020\u0072e\u0073\u006c\u0069\u0063\u0065\u0020\u006f\u006e\u006c\u0079\u002e\u0020L\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0043\u0061\u0070\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u006e\u003a\u0020'\u0025\u0064\u0027",len (_ed ._ec ),cap (_ed ._ec ),_gfg );
_dd .Log .Trace ("\u0020\u006e\u0020\u003c\u003d\u0020\u0063\u0020\u002f\u0020\u0032\u0020\u002d\u006d\u002e \u0043:\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u006d\u003a\u0020\u0027\u0025\u0064\u0027",_fea ,_cbb );copy (_ed ._ec ,_ed ._ec [_ed .fullOffset ():]);
case _fea > _fa -_fea -_gfg :_dd .Log .Error ("\u0042\u0055F\u0046\u0045\u0052 \u0074\u006f\u006f\u0020\u006c\u0061\u0072\u0067\u0065");return ;default:_fc :=make ([]byte ,2*_fea +_gfg );copy (_fc ,_ed ._ec );_ed ._ec =_fc ;};_ed ._ec =_ed ._ec [:_cbb +_gfg ];
};func (_eaaf *Writer )byteCapacity ()int {_bga :=len (_eaaf ._edb )-_eaaf ._adg ;if _eaaf ._fgb !=0{_bga --;};return _bga ;};func (_abc *Writer )WriteByte (c byte )error {return _abc .writeByte (c )};type readerSource struct{_dfb []byte ;_ege int ;_fgc int ;
};func (_cac *Writer )writeBit (_fdd uint8 )error {if len (_cac ._edb )-1< _cac ._adg {return _f .EOF ;};_efe :=_cac ._fgb ;if _cac ._faa {_efe =7-_cac ._fgb ;};_cac ._edb [_cac ._adg ]|=byte (uint16 (_fdd <<_efe )&0xff);_cac ._fgb ++;if _cac ._fgb ==8{_cac ._adg ++;
_cac ._fgb =0;};return nil ;};var (_ _f .Reader =&Reader {};_ _f .ByteReader =&Reader {};_ _f .Seeker =&Reader {};_ StreamReader =&Reader {};);func BufferedMSB ()*BufferedWriter {return &BufferedWriter {_ff :true }};var _ _f .ByteWriter =&BufferedWriter {};
func (_adb *Reader )ReadBit ()(_edg int ,_egd error ){_dfg ,_egd :=_adb .readBool ();if _egd !=nil {return 0,_egd ;};if _dfg {_edg =1;};return _edg ,nil ;};func (_gg *BufferedWriter )ResetBitIndex (){_gg ._a =0};func (_cfd *Writer )Data ()[]byte {return _cfd ._edb };
func (_bgc *Reader )readBufferByte ()(byte ,error ){if _bgc ._ggb >=int64 (_bgc ._efd ._fgc ){return 0,_f .EOF ;};_bgc ._aed =-1;_fcg :=_bgc ._efd ._dfb [int64 (_bgc ._efd ._ege )+_bgc ._ggb ];_bgc ._ggb ++;_bgc ._adcd =int (_fcg );return _fcg ,nil ;};
func (_ggd *Writer )WriteBits (bits uint64 ,number int )(_abd int ,_gff error ){const _afd ="\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065r\u0042\u0069\u0074\u0073";if number < 0||number > 64{return 0,_fe .Errorf (_afd ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};if number ==0{return 0,nil ;};_bgdd :=number /8;if _bgdd > 0{_gbd :=number -_bgdd *8;for _cgff :=_bgdd -1;_cgff >=0;_cgff --{_eea :=byte ((bits >>uint (_cgff *8+_gbd ))&0xff);if _gff =_ggd .WriteByte (_eea );_gff !=nil {return _abd ,_fe .Wrapf (_gff ,_afd ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bgdd -_cgff +1);
};};number -=_bgdd *8;if number ==0{return _bgdd ,nil ;};};var _bdfc int ;for _aag :=0;_aag < number ;_aag ++{if _ggd ._faa {_bdfc =int ((bits >>uint (number -1-_aag ))&0x1);}else {_bdfc =int (bits &0x1);bits >>=1;};if _gff =_ggd .WriteBit (_bdfc );_gff !=nil {return _abd ,_fe .Wrapf (_gff ,_afd ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_aag );
};};return _bgdd ,nil ;};func (_eg *BufferedWriter )expandIfNeeded (_bdd int ){if !_eg .tryGrowByReslice (_bdd ){_eg .grow (_bdd );};};func NewWriter (data []byte )*Writer {return &Writer {_edb :data }};type BitWriter interface{WriteBit (_ac int )error ;
WriteBits (_ae uint64 ,_bg int )(_ad int ,_cfe error );FinishByte ();SkipBits (_fcf int )error ;};func (_cf *BufferedWriter )WriteBit (bit int )error {if bit !=1&&bit !=0{return _fe .Errorf ("\u0042\u0075\u0066fe\u0072\u0065\u0064\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0062\u0069\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u006du\u0073\u0074\u0020\u0062e\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u007b\u0030\u002c\u0031\u007d\u0020\u0062\u0075\u0074\u0020\u0069\u0073\u003a\u0020\u0025\u0064",bit );
};if len (_cf ._ec )-1< _cf ._bf {_cf .expandIfNeeded (1);};_aa :=_cf ._a ;if _cf ._ff {_aa =7-_cf ._a ;};_cf ._ec [_cf ._bf ]|=byte (uint16 (bit <<_aa )&0xff);_cf ._a ++;if _cf ._a ==8{_cf ._bf ++;_cf ._a =0;};return nil ;};var _ _f .Writer =&BufferedWriter {};
func (_bbf *Reader )read (_edc []byte )(int ,error ){if _bbf ._ggb >=int64 (_bbf ._efd ._fgc ){return 0,_f .EOF ;};_bbf ._aed =-1;_abf :=copy (_edc ,_bbf ._efd ._dfb [(int64 (_bbf ._efd ._ege )+_bbf ._ggb ):(_bbf ._efd ._ege +_bbf ._efd ._fgc )]);_bbf ._ggb +=int64 (_abf );
return _abf ,nil ;};type Writer struct{_edb []byte ;_fgb uint8 ;_adg int ;_faa bool ;};func (_ebg *Reader )ReadByte ()(byte ,error ){if _ebg ._dff ==0{return _ebg .readBufferByte ();};return _ebg .readUnalignedByte ();};type Reader struct{_efd readerSource ;
_ga byte ;_dff byte ;_ggb int64 ;_adcd int ;_aed int ;_bfb int64 ;_ffc byte ;_bfg byte ;_cae int ;};func (_fac *BufferedWriter )writeFullBytes (_df []byte )int {_cbf :=copy (_fac ._ec [_fac .fullOffset ():],_df );_fac ._bf +=_cbf ;return _cbf ;};func (_dc *BufferedWriter )Len ()int {return _dc .byteCapacity ()};
func (_gba *BufferedWriter )WriteByte (bt byte )error {if _gba ._bf > len (_gba ._ec )-1||(_gba ._bf ==len (_gba ._ec )-1&&_gba ._a !=0){_gba .expandIfNeeded (1);};_gba .writeByte (bt );return nil ;};func (_bdf *Reader )ReadUint32 ()(uint32 ,error ){_ccf :=make ([]byte ,4);
_ ,_ceb :=_bdf .Read (_ccf );if _ceb !=nil {return 0,_ceb ;};return _c .BigEndian .Uint32 (_ccf ),nil ;};const (_g =64;_fa =int (^uint (0)>>1););func (_fdg *Reader )Seek (offset int64 ,whence int )(int64 ,error ){_fdg ._aed =-1;_fdg ._dff =0;_fdg ._ga =0;
_fdg ._adcd =0;var _ade int64 ;switch whence {case _f .SeekStart :_ade =offset ;case _f .SeekCurrent :_ade =_fdg ._ggb +offset ;case _f .SeekEnd :_ade =int64 (_fdg ._efd ._fgc )+offset ;default:return 0,_d .New ("\u0072\u0065\u0061de\u0072\u002e\u0052\u0065\u0061\u0064\u0065\u0072\u002eS\u0065e\u006b:\u0020i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0068\u0065\u006e\u0063\u0065");
};if _ade < 0{return 0,_d .New ("\u0072\u0065a\u0064\u0065\u0072\u002eR\u0065\u0061d\u0065\u0072\u002e\u0053\u0065\u0065\u006b\u003a \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u006f\u006e");};_fdg ._ggb =_ade ;
_fdg ._dff =0;return _ade ,nil ;};func (_db *BufferedWriter )WriteBits (bits uint64 ,number int )(_efb int ,_gf error ){const _gge ="\u0042u\u0066\u0066\u0065\u0072e\u0064\u0057\u0072\u0069\u0074e\u0072.\u0057r\u0069\u0074\u0065\u0072\u0042\u0069\u0074s";
if number < 0||number > 64{return 0,_fe .Errorf (_gge ,"\u0062i\u0074\u0073 \u006e\u0075\u006db\u0065\u0072\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020r\u0061\u006e\u0067\u0065\u0020\u003c\u0030\u002c\u0036\u0034\u003e,\u0020\u0069\u0073\u003a\u0020\u0027\u0025\u0064\u0027",number );
};_bbg :=number /8;if _bbg > 0{_fg :=number -_bbg *8;for _eff :=_bbg -1;_eff >=0;_eff --{_bc :=byte ((bits >>uint (_eff *8+_fg ))&0xff);if _gf =_db .WriteByte (_bc );_gf !=nil {return _efb ,_fe .Wrapf (_gf ,_gge ,"\u0062\u0079\u0074\u0065\u003a\u0020\u0027\u0025\u0064\u0027",_bbg -_eff +1);
};};number -=_bbg *8;if number ==0{return _bbg ,nil ;};};var _be int ;for _bd :=0;_bd < number ;_bd ++{if _db ._ff {_be =int ((bits >>uint (number -1-_bd ))&0x1);}else {_be =int (bits &0x1);bits >>=1;};if _gf =_db .WriteBit (_be );_gf !=nil {return _efb ,_fe .Wrapf (_gf ,_gge ,"\u0062i\u0074\u003a\u0020\u0025\u0064",_bd );
};};return _bbg ,nil ;};func (_af *BufferedWriter )Reset (){_af ._ec =_af ._ec [:0];_af ._bf =0;_af ._a =0};func (_beg *Reader )AbsolutePosition ()int64 {return _beg ._ggb +int64 (_beg ._efd ._ege )};func (_ea *Reader )NewPartialReader (offset ,length int ,relative bool )(*Reader ,error ){if offset < 0{return nil ,_d .New ("p\u0061\u0072\u0074\u0069\u0061\u006c\u0020\u0072\u0065\u0061\u0064\u0065\u0072\u0020\u006f\u0066\u0066\u0073e\u0074\u0020\u0063\u0061\u006e\u006e\u006f\u0074\u0020\u0062e \u006e\u0065\u0067a\u0074i\u0076\u0065");
};if relative {offset =_ea ._efd ._ege +offset ;};if length > 0{_fgd :=len (_ea ._efd ._dfb );if relative {_fgd =_ea ._efd ._fgc ;};if offset +length > _fgd {return nil ,_e .Errorf ("\u0070\u0061r\u0074\u0069\u0061l\u0020\u0072\u0065\u0061\u0064e\u0072\u0020\u006f\u0066\u0066se\u0074\u0028\u0025\u0064\u0029\u002b\u006c\u0065\u006e\u0067\u0074\u0068\u0028\u0025\u0064\u0029\u003d\u0025d\u0020i\u0073\u0020\u0067\u0072\u0065\u0061ter\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u006f\u0072ig\u0069n\u0061\u006c\u0020\u0072e\u0061d\u0065r\u0020\u006ce\u006e\u0067th\u003a\u0020\u0025\u0064",offset ,length ,offset +length ,_ea ._efd ._fgc );
};};if length < 0{_fbf :=len (_ea ._efd ._dfb );if relative {_fbf =_ea ._efd ._fgc ;};length =_fbf -offset ;};return &Reader {_efd :readerSource {_dfb :_ea ._efd ._dfb ,_fgc :length ,_ege :offset }},nil ;};func (_dg *Reader )BitPosition ()int {return int (_dg ._dff )};
func (_cbd *Writer )ResetBit (){_cbd ._fgb =0};func (_eeg *Writer )WriteBit (bit int )error {switch bit {case 0,1:return _eeg .writeBit (uint8 (bit ));};return _fe .Error ("\u0057\u0072\u0069\u0074\u0065\u0042\u0069\u0074","\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0062\u0069\u0074\u0020v\u0061\u006c\u0075\u0065");
};func (_aebe *Reader )Read (p []byte )(_da int ,_ggc error ){if _aebe ._dff ==0{return _aebe .read (p );};for ;_da < len (p );_da ++{if p [_da ],_ggc =_aebe .readUnalignedByte ();_ggc !=nil {return 0,_ggc ;};};return _da ,nil ;};func (_ag *BufferedWriter )writeShiftedBytes (_eed []byte )int {for _ ,_ecb :=range _eed {_ag .writeByte (_ecb );
};return len (_eed );};func (_bgd *Writer )FinishByte (){if _bgd ._fgb ==0{return ;};_bgd ._fgb =0;_bgd ._adg ++;};type BinaryWriter interface{BitWriter ;_f .Writer ;_f .ByteWriter ;Data ()[]byte ;};func (_ca *BufferedWriter )FinishByte (){if _ca ._a ==0{return ;
};_ca ._a =0;_ca ._bf ++;};func (_gga *BufferedWriter )tryGrowByReslice (_fb int )bool {if _cfb :=len (_gga ._ec );_fb <=cap (_gga ._ec )-_cfb {_gga ._ec =_gga ._ec [:_cfb +_fb ];return true ;};return false ;};func (_aga *Writer )SkipBits (skip int )error {const _gfgb ="\u0057r\u0069t\u0065\u0072\u002e\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073";
if skip ==0{return nil ;};_cbc :=int (_aga ._fgb )+skip ;if _cbc >=0&&_cbc < 8{_aga ._fgb =uint8 (_cbc );return nil ;};_cbc =int (_aga ._fgb )+_aga ._adg *8+skip ;if _cbc < 0{return _fe .Errorf (_gfgb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_ceg :=_cbc /8;_cgde :=_cbc %8;_dd .Log .Trace ("\u0053\u006b\u0069\u0070\u0042\u0069\u0074\u0073");_dd .Log .Trace ("\u0042\u0069\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u0042\u0079\u0074\u0065\u0049n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u002c\u0020\u0046\u0075\u006c\u006c\u0042\u0069\u0074\u0073\u003a\u0020'\u0025\u0064\u0027\u002c\u0020\u004c\u0065\u006e\u003a\u0020\u0027\u0025\u0064\u0027,\u0020\u0043\u0061p\u003a\u0020\u0027\u0025\u0064\u0027",_aga ._fgb ,_aga ._adg ,int (_aga ._fgb )+(_aga ._adg )*8,len (_aga ._edb ),cap (_aga ._edb ));
_dd .Log .Trace ("S\u006b\u0069\u0070\u003a\u0020\u0027%\u0064\u0027\u002c\u0020\u0064\u003a \u0027\u0025\u0064\u0027\u002c\u0020\u0062i\u0074\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025d\u0027",skip ,_cbc ,_cgde );_aga ._fgb =uint8 (_cgde );
if _gdf :=_ceg -_aga ._adg ;_gdf > 0&&len (_aga ._edb )-1< _ceg {_dd .Log .Trace ("\u0042\u0079\u0074e\u0044\u0069\u0066\u0066\u003a\u0020\u0025\u0064",_gdf );return _fe .Errorf (_gfgb ,"\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_aga ._adg =_ceg ;_dd .Log .Trace ("\u0042\u0069\u0074I\u006e\u0064\u0065\u0078:\u0020\u0027\u0025\u0064\u0027\u002c\u0020B\u0079\u0074\u0065\u0049\u006e\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027",_aga ._fgb ,_aga ._adg );return nil ;};func (_de *Writer )writeByte (_gfgc byte )error {if _de ._adg > len (_de ._edb )-1{return _f .EOF ;
};if _de ._adg ==len (_de ._edb )-1&&_de ._fgb !=0{return _f .EOF ;};if _de ._fgb ==0{_de ._edb [_de ._adg ]=_gfgc ;_de ._adg ++;return nil ;};if _de ._faa {_de ._edb [_de ._adg ]|=_gfgc >>_de ._fgb ;_de ._adg ++;_de ._edb [_de ._adg ]=byte (uint16 (_gfgc )<<(8-_de ._fgb )&0xff);
}else {_de ._edb [_de ._adg ]|=byte (uint16 (_gfgc )<<_de ._fgb &0xff);_de ._adg ++;_de ._edb [_de ._adg ]=_gfgc >>(8-_de ._fgb );};return nil ;};func (_ddd *BufferedWriter )Data ()[]byte {return _ddd ._ec };func NewWriterMSB (data []byte )*Writer {return &Writer {_edb :data ,_faa :true }};
type StreamReader interface{_f .Reader ;_f .ByteReader ;_f .Seeker ;Align ()byte ;BitPosition ()int ;Mark ();Length ()uint64 ;ReadBit ()(int ,error );ReadBits (_adc byte )(uint64 ,error );ReadBool ()(bool ,error );ReadUint32 ()(uint32 ,error );Reset ();
AbsolutePosition ()int64 ;};func (_eba *Reader )ReadBool ()(bool ,error ){return _eba .readBool ()};func (_bfbf *Reader )ConsumeRemainingBits ()(uint64 ,error ){if _bfbf ._dff !=0{return _bfbf .ReadBits (_bfbf ._dff );};return 0,nil ;};func (_bgg *Reader )readUnalignedByte ()(_dda byte ,_fedb error ){_ge :=_bgg ._dff ;
_dda =_bgg ._ga <<(8-_ge );_bgg ._ga ,_fedb =_bgg .readBufferByte ();if _fedb !=nil {return 0,_fedb ;};_dda |=_bgg ._ga >>_ge ;_bgg ._ga &=1<<_ge -1;return _dda ,nil ;};func (_dgd *Writer )UseMSB ()bool {return _dgd ._faa };func (_cg *BufferedWriter )fullOffset ()int {_ab :=_cg ._bf ;
if _cg ._a !=0{_ab ++;};return _ab ;};func (_aede *Reader )Reset (){_aede ._ggb =_aede ._bfb ;_aede ._dff =_aede ._ffc ;_aede ._ga =_aede ._bfg ;_aede ._adcd =_aede ._cae ;};func (_bab *Writer )Write (p []byte )(int ,error ){if len (p )> _bab .byteCapacity (){return 0,_f .EOF ;
};for _ ,_eaa :=range p {if _cdd :=_bab .writeByte (_eaa );_cdd !=nil {return 0,_cdd ;};};return len (p ),nil ;};