//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sampling ;import (_de "github.com/unidoc/unipdf/v3/internal/bitwise";_ad "github.com/unidoc/unipdf/v3/internal/imageutil";_d "io";);func (_f *Reader )ReadSample ()(uint32 ,error ){if _f ._ge ==_f ._g .Height {return 0,_d .EOF ;};_cc ,_dg :=_f ._b .ReadBits (byte (_f ._g .BitsPerComponent ));
if _dg !=nil {return 0,_dg ;};_f ._c --;if _f ._c ==0{_f ._c =_f ._g .ColorComponents ;_f ._bg ++;};if _f ._bg ==_f ._g .Width {if _f ._da {_f ._b .ConsumeRemainingBits ();};_f ._bg =0;_f ._ge ++;};return uint32 (_cc ),nil ;};func (_bbg *Writer )WriteSamples (samples []uint32 )error {for _dag :=0;
_dag < len (samples );_dag ++{if _bed :=_bbg .WriteSample (samples [_dag ]);_bed !=nil {return _bed ;};};return nil ;};func ResampleBytes (data []byte ,bitsPerSample int )[]uint32 {var _gc []uint32 ;_ag :=bitsPerSample ;var _ef uint32 ;var _bc byte ;_dgg :=0;
_bgf :=0;_cf :=0;for _cf < len (data ){if _dgg > 0{_fd :=_dgg ;if _ag < _fd {_fd =_ag ;};_ef =(_ef <<uint (_fd ))|uint32 (_bc >>uint (8-_fd ));_dgg -=_fd ;if _dgg > 0{_bc =_bc <<uint (_fd );}else {_bc =0;};_ag -=_fd ;if _ag ==0{_gc =append (_gc ,_ef );
_ag =bitsPerSample ;_ef =0;_bgf ++;};}else {_be :=data [_cf ];_cf ++;_dea :=8;if _ag < _dea {_dea =_ag ;};_dgg =8-_dea ;_ef =(_ef <<uint (_dea ))|uint32 (_be >>uint (_dgg ));if _dea < 8{_bc =_be <<uint (_dea );};_ag -=_dea ;if _ag ==0{_gc =append (_gc ,_ef );
_ag =bitsPerSample ;_ef =0;_bgf ++;};};};for _dgg >=bitsPerSample {_df :=_dgg ;if _ag < _df {_df =_ag ;};_ef =(_ef <<uint (_df ))|uint32 (_bc >>uint (8-_df ));_dgg -=_df ;if _dgg > 0{_bc =_bc <<uint (_df );}else {_bc =0;};_ag -=_df ;if _ag ==0{_gc =append (_gc ,_ef );
_ag =bitsPerSample ;_ef =0;_bgf ++;};};return _gc ;};type Reader struct{_g _ad .ImageBase ;_b *_de .Reader ;_bg ,_ge ,_c int ;_da bool ;};func NewReader (img _ad .ImageBase )*Reader {return &Reader {_b :_de .NewReader (img .Data ),_g :img ,_c :img .ColorComponents ,_da :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type SampleWriter interface{WriteSample (_gd uint32 )error ;WriteSamples (_ece []uint32 )error ;};func NewWriter (img _ad .ImageBase )*Writer {return &Writer {_agg :_de .NewWriterMSB (img .Data ),_eb :img ,_geb :img .ColorComponents ,_bf :img .BytesPerLine *8!=img .ColorComponents *img .BitsPerComponent *img .Width };
};type SampleReader interface{ReadSample ()(uint32 ,error );ReadSamples (_e []uint32 )error ;};func (_cb *Writer )WriteSample (sample uint32 )error {if _ ,_cga :=_cb ._agg .WriteBits (uint64 (sample ),_cb ._eb .BitsPerComponent );_cga !=nil {return _cga ;
};_cb ._geb --;if _cb ._geb ==0{_cb ._geb =_cb ._eb .ColorComponents ;_cb ._aggf ++;};if _cb ._aggf ==_cb ._eb .Width {if _cb ._bf {_cb ._agg .FinishByte ();};_cb ._aggf =0;};return nil ;};func ResampleUint32 (data []uint32 ,bitsPerInputSample int ,bitsPerOutputSample int )[]uint32 {var _ga []uint32 ;
_ba :=bitsPerOutputSample ;var _fb uint32 ;var _fa uint32 ;_ec :=0;_ff :=0;_cdc :=0;for _cdc < len (data ){if _ec > 0{_bb :=_ec ;if _ba < _bb {_bb =_ba ;};_fb =(_fb <<uint (_bb ))|(_fa >>uint (bitsPerInputSample -_bb ));_ec -=_bb ;if _ec > 0{_fa =_fa <<uint (_bb );
}else {_fa =0;};_ba -=_bb ;if _ba ==0{_ga =append (_ga ,_fb );_ba =bitsPerOutputSample ;_fb =0;_ff ++;};}else {_ea :=data [_cdc ];_cdc ++;_cg :=bitsPerInputSample ;if _ba < _cg {_cg =_ba ;};_ec =bitsPerInputSample -_cg ;_fb =(_fb <<uint (_cg ))|(_ea >>uint (_ec ));
if _cg < bitsPerInputSample {_fa =_ea <<uint (_cg );};_ba -=_cg ;if _ba ==0{_ga =append (_ga ,_fb );_ba =bitsPerOutputSample ;_fb =0;_ff ++;};};};for _ec >=bitsPerOutputSample {_fec :=_ec ;if _ba < _fec {_fec =_ba ;};_fb =(_fb <<uint (_fec ))|(_fa >>uint (bitsPerInputSample -_fec ));
_ec -=_fec ;if _ec > 0{_fa =_fa <<uint (_fec );}else {_fa =0;};_ba -=_fec ;if _ba ==0{_ga =append (_ga ,_fb );_ba =bitsPerOutputSample ;_fb =0;_ff ++;};};if _ba > 0&&_ba < bitsPerOutputSample {_fb <<=uint (_ba );_ga =append (_ga ,_fb );};return _ga ;};
func (_fg *Reader )ReadSamples (samples []uint32 )(_fe error ){for _cd :=0;_cd < len (samples );_cd ++{samples [_cd ],_fe =_fg .ReadSample ();if _fe !=nil {return _fe ;};};return nil ;};type Writer struct{_eb _ad .ImageBase ;_agg *_de .Writer ;_aggf ,_geb int ;
_bf bool ;};