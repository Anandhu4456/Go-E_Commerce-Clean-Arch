//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package transform ;import (_e "fmt";_a "github.com/unidoc/unipdf/v3/common";_c "math";);const _dd =1e-6;func NewPoint (x ,y float64 )Point {return Point {X :x ,Y :y }};func (_ef Matrix )ScalingFactorY ()float64 {return _c .Hypot (_ef [3],_ef [4])};func (_af *Matrix )Concat (b Matrix ){*_af =Matrix {b [0]*_af [0]+b [1]*_af [3],b [0]*_af [1]+b [1]*_af [4],0,b [3]*_af [0]+b [4]*_af [3],b [3]*_af [1]+b [4]*_af [4],0,b [6]*_af [0]+b [7]*_af [3]+_af [6],b [6]*_af [1]+b [7]*_af [4]+_af [7],1};
_af .clampRange ();};func (_ddg Point )Rotate (theta float64 )Point {_face :=_c .Hypot (_ddg .X ,_ddg .Y );_ddb :=_c .Atan2 (_ddg .Y ,_ddg .X );_bab ,_gae :=_c .Sincos (_ddb +theta /180.0*_c .Pi );return Point {_face *_gae ,_face *_bab };};func ShearMatrix (x ,y float64 )Matrix {return NewMatrix (1,y ,x ,1,0,0)};
func (_d Matrix )Rotate (theta float64 )Matrix {return _d .Mult (RotationMatrix (theta ))};func (_cdb *Point )Set (x ,y float64 ){_cdb .X ,_cdb .Y =x ,y };func (_bc Matrix )Angle ()float64 {_cb :=_c .Atan2 (-_bc [1],_bc [0]);if _cb < 0.0{_cb +=2*_c .Pi ;
};return _cb /_c .Pi *180.0;};func (_gg *Matrix )Set (a ,b ,c ,d ,tx ,ty float64 ){_gg [0],_gg [1]=a ,b ;_gg [3],_gg [4]=c ,d ;_gg [6],_gg [7]=tx ,ty ;_gg .clampRange ();};func (_ba *Matrix )Shear (x ,y float64 ){_ba .Concat (ShearMatrix (x ,y ))};func (_ffe Point )Interpolate (b Point ,t float64 )Point {return Point {X :(1-t )*_ffe .X +t *b .X ,Y :(1-t )*_ffe .Y +t *b .Y };
};const _db =1e-10;func (_eb Matrix )ScalingFactorX ()float64 {return _c .Hypot (_eb [0],_eb [1])};func (_eg Matrix )Transform (x ,y float64 )(float64 ,float64 ){_fga :=x *_eg [0]+y *_eg [3]+_eg [6];_fag :=x *_eg [1]+y *_eg [4]+_eg [7];return _fga ,_fag ;
};func RotationMatrix (angle float64 )Matrix {_fb :=_c .Cos (angle );_ce :=_c .Sin (angle );return NewMatrix (_fb ,_ce ,-_ce ,_fb ,0,0);};func (_aa Matrix )Identity ()bool {return _aa [0]==1&&_aa [1]==0&&_aa [2]==0&&_aa [3]==0&&_aa [4]==1&&_aa [5]==0&&_aa [6]==0&&_aa [7]==0&&_aa [8]==1;
};func (_fgf Matrix )Singular ()bool {return _c .Abs (_fgf [0]*_fgf [4]-_fgf [1]*_fgf [3])< _db };func (_ag Matrix )Round (precision float64 )Matrix {for _fa :=range _ag {_ag [_fa ]=_c .Round (_ag [_fa ]/precision )*precision ;};return _ag ;};type Matrix [9]float64 ;
func IdentityMatrix ()Matrix {return NewMatrix (1,0,0,1,0,0)};const _gc =1e9;func NewMatrix (a ,b ,c ,d ,tx ,ty float64 )Matrix {_b :=Matrix {a ,b ,0,c ,d ,0,tx ,ty ,1};_b .clampRange ();return _b ;};func (_bcc *Point )transformByMatrix (_gge Matrix ){_bcc .X ,_bcc .Y =_gge .Transform (_bcc .X ,_bcc .Y )};
func (_ea *Matrix )clampRange (){for _fac ,_cc :=range _ea {if _cc > _gc {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cc ,_gc );_ea [_fac ]=_gc ;}else if _cc < -_gc {_a .Log .Debug ("\u0043L\u0041M\u0050\u003a\u0020\u0025\u0067\u0020\u002d\u003e\u0020\u0025\u0067",_cc ,-_gc );
_ea [_fac ]=-_gc ;};};};func (_dbd Matrix )Unrealistic ()bool {_fbc ,_gf ,_bae ,_fbg :=_c .Abs (_dbd [0]),_c .Abs (_dbd [1]),_c .Abs (_dbd [3]),_c .Abs (_dbd [4]);_ca :=_fbc > _dd &&_fbg > _dd ;_ffa :=_gf > _dd &&_bae > _dd ;return !(_ca ||_ffa );};const _fd =1.0e-6;
func (_eac *Point )Transform (a ,b ,c ,d ,tx ,ty float64 ){_efbf :=NewMatrix (a ,b ,c ,d ,tx ,ty );_eac .transformByMatrix (_efbf );};type Point struct{X float64 ;Y float64 ;};func (_fgg Point )Displace (delta Point )Point {return Point {_fgg .X +delta .X ,_fgg .Y +delta .Y }};
func ScaleMatrix (x ,y float64 )Matrix {return NewMatrix (x ,0,0,y ,0,0)};func NewMatrixFromTransforms (xScale ,yScale ,theta ,tx ,ty float64 )Matrix {return IdentityMatrix ().Scale (xScale ,yScale ).Rotate (theta ).Translate (tx ,ty );};func (_ad Matrix )Translation ()(float64 ,float64 ){return _ad [6],_ad [7]};
func (_bf Matrix )Scale (xScale ,yScale float64 )Matrix {return _bf .Mult (ScaleMatrix (xScale ,yScale ))};func (_cadc Point )String ()string {return _e .Sprintf ("(\u0025\u002e\u0032\u0066\u002c\u0025\u002e\u0032\u0066\u0029",_cadc .X ,_cadc .Y );};func (_bd Matrix )Translate (tx ,ty float64 )Matrix {return _bd .Mult (TranslationMatrix (tx ,ty ))};
func (_cad Point )Distance (b Point )float64 {return _c .Hypot (_cad .X -b .X ,_cad .Y -b .Y )};func (_cfg *Matrix )Clone ()Matrix {return NewMatrix (_cfg [0],_cfg [1],_cfg [3],_cfg [4],_cfg [6],_cfg [7]);};func (_ec Matrix )Inverse ()(Matrix ,bool ){_bgb ,_ee :=_ec [0],_ec [1];
_df ,_de :=_ec [3],_ec [4];_egc ,_ga :=_ec [6],_ec [7];_dfa :=_bgb *_de -_ee *_df ;if _c .Abs (_dfa )< _fd {return Matrix {},false ;};_cd ,_afe :=_de /_dfa ,-_ee /_dfa ;_gd ,_efb :=-_df /_dfa ,_bgb /_dfa ;_aaa :=-(_cd *_egc +_gd *_ga );_afc :=-(_afe *_egc +_efb *_ga );
return NewMatrix (_cd ,_afe ,_gd ,_efb ,_aaa ,_afc ),true ;};func (_be Matrix )String ()string {_cea ,_bg ,_g ,_fg ,_ff ,_fge :=_be [0],_be [1],_be [3],_be [4],_be [6],_be [7];return _e .Sprintf ("\u005b\u00257\u002e\u0034\u0066\u002c%\u0037\u002e4\u0066\u002c\u0025\u0037\u002e\u0034\u0066\u002c%\u0037\u002e\u0034\u0066\u003a\u0025\u0037\u002e\u0034\u0066\u002c\u00257\u002e\u0034\u0066\u005d",_cea ,_bg ,_g ,_fg ,_ff ,_fge );
};func (_cf Matrix )Mult (b Matrix )Matrix {_cf .Concat (b );return _cf };func TranslationMatrix (tx ,ty float64 )Matrix {return NewMatrix (1,0,0,1,tx ,ty )};