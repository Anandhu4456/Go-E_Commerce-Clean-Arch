//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package imageutil ;import (_ba "encoding/binary";_g "errors";_ge "fmt";_d "github.com/unidoc/unipdf/v3/common";_ff "github.com/unidoc/unipdf/v3/internal/bitwise";_ee "image";_b "image/color";_f "image/draw";_a "math";);var _ Image =&NRGBA64 {};type Gray8 struct{ImageBase };
func (_cgde *NRGBA64 )Set (x ,y int ,c _b .Color ){_aabe :=(y *_cgde .Width +x )*2;_gbdg :=_aabe *3;if _gbdg +5>=len (_cgde .Data ){return ;};_egeg :=_b .NRGBA64Model .Convert (c ).(_b .NRGBA64 );_cgde .setNRGBA64 (_gbdg ,_egeg ,_aabe );};func (_bafgd *RGBA32 )Copy ()Image {return &RGBA32 {ImageBase :_bafgd .copy ()}};
func _becd (_edcf _ee .Image )(Image ,error ){if _bdfg ,_fee :=_edcf .(*RGBA32 );_fee {return _bdfg .Copy (),nil ;};_bfac ,_gdfd ,_adcge :=_feddd (_edcf ,1);_cbafd :=&RGBA32 {ImageBase :NewImageBase (_bfac .Max .X ,_bfac .Max .Y ,8,3,nil ,_adcge ,nil )};
_fdfd (_edcf ,_cbafd ,_bfac );if len (_adcge )!=0&&!_gdfd {if _dcdaa :=_bddgc (_adcge ,_cbafd );_dcdaa !=nil {return nil ,_dcdaa ;};};return _cbafd ,nil ;};func _agbc (_cfgc _ee .Image ,_egcb Image ,_gca _ee .Rectangle ){for _dfc :=0;_dfc < _gca .Max .X ;
_dfc ++{for _dad :=0;_dad < _gca .Max .Y ;_dad ++{_bad :=_cfgc .At (_dfc ,_dad );_egcb .Set (_dfc ,_dad ,_bad );};};};var _ Gray =&Monochrome {};func (_dbe *Gray2 )At (x ,y int )_b .Color {_dgfa ,_ :=_dbe .ColorAt (x ,y );return _dgfa };func (_ddea *ImageBase )Pix ()[]byte {return _ddea .Data };
func (_gcgc *NRGBA64 )ColorModel ()_b .Model {return _b .NRGBA64Model };func (_fgac *Gray4 )Validate ()error {if len (_fgac .Data )!=_fgac .Height *_fgac .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _aeg (_dgg _ee .Image )(Image ,error ){if _beg ,_fac :=_dgg .(*Gray2 );
_fac {return _beg .Copy (),nil ;};_cfgb :=_dgg .Bounds ();_ceed ,_ffee :=NewImage (_cfgb .Max .X ,_cfgb .Max .Y ,2,1,nil ,nil ,nil );if _ffee !=nil {return nil ,_ffee ;};_aaba (_dgg ,_ceed ,_cfgb );return _ceed ,nil ;};func ColorAtGray8BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_cbde :=y *bytesPerLine +x ;
if _cbde >=len (data ){return _b .Gray {},_ge .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_aage :=data [_cbde ];if len (decode )==2{_aage =uint8 (uint32 (LinearInterpolate (float64 (_aage ),0,255,decode [0],decode [1]))&0xff);};return _b .Gray {Y :_aage },nil ;};func _bfcg (_dbac *Monochrome ,_acgb ,_acag int ,_cgad ,_adgca int ,_cafb RasterOperator ){var (_eeeg int ;
_ffgb byte ;_eebb ,_edee int ;_egbb int ;);_dcgad :=_cgad >>3;_cdea :=_cgad &7;if _cdea > 0{_ffgb =_gedd [_cdea ];};_eeeg =_dbac .BytesPerLine *_acag +(_acgb >>3);switch _cafb {case PixClr :for _eebb =0;_eebb < _adgca ;_eebb ++{_egbb =_eeeg +_eebb *_dbac .BytesPerLine ;
for _edee =0;_edee < _dcgad ;_edee ++{_dbac .Data [_egbb ]=0x0;_egbb ++;};if _cdea > 0{_dbac .Data [_egbb ]=_dabg (_dbac .Data [_egbb ],0x0,_ffgb );};};case PixSet :for _eebb =0;_eebb < _adgca ;_eebb ++{_egbb =_eeeg +_eebb *_dbac .BytesPerLine ;for _edee =0;
_edee < _dcgad ;_edee ++{_dbac .Data [_egbb ]=0xff;_egbb ++;};if _cdea > 0{_dbac .Data [_egbb ]=_dabg (_dbac .Data [_egbb ],0xff,_ffgb );};};case PixNotDst :for _eebb =0;_eebb < _adgca ;_eebb ++{_egbb =_eeeg +_eebb *_dbac .BytesPerLine ;for _edee =0;_edee < _dcgad ;
_edee ++{_dbac .Data [_egbb ]=^_dbac .Data [_egbb ];_egbb ++;};if _cdea > 0{_dbac .Data [_egbb ]=_dabg (_dbac .Data [_egbb ],^_dbac .Data [_egbb ],_ffgb );};};};};func _ebb (_egc *Monochrome ,_aga int ,_ece []byte )(_adbg *Monochrome ,_egec error ){const _geec ="\u0072\u0065d\u0075\u0063\u0065R\u0061\u006e\u006b\u0042\u0069\u006e\u0061\u0072\u0079";
if _egc ==nil {return nil ,_g .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");};if _aga < 1||_aga > 4{return nil ,_g .New ("\u006c\u0065\u0076\u0065\u006c\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0069\u006e\u0020\u0073e\u0074\u0020\u007b\u0031\u002c\u0032\u002c\u0033\u002c\u0034\u007d");
};if _egc .Height <=1{return nil ,_g .New ("\u0073\u006f\u0075rc\u0065\u0020\u0068\u0065\u0069\u0067\u0068\u0074\u0020m\u0075s\u0074 \u0062e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0027\u0032\u0027");};_adbg =_fbd (_egc .Width /2,_egc .Height /2);
if _ece ==nil {_ece =_feb ();};_cfg :=_cdgb (_egc .BytesPerLine ,2*_adbg .BytesPerLine );switch _aga {case 1:_egec =_bde (_egc ,_adbg ,_ece ,_cfg );case 2:_egec =_edab (_egc ,_adbg ,_ece ,_cfg );case 3:_egec =_dea (_egc ,_adbg ,_ece ,_cfg );case 4:_egec =_age (_egc ,_adbg ,_ece ,_cfg );
};if _egec !=nil {return nil ,_egec ;};return _adbg ,nil ;};type ImageBase struct{Width ,Height int ;BitsPerComponent ,ColorComponents int ;Data ,Alpha []byte ;Decode []float64 ;BytesPerLine int ;};func (_aefe *Gray2 )Copy ()Image {return &Gray2 {ImageBase :_aefe .copy ()}};
func _age (_ffe ,_gbf *Monochrome ,_edc []byte ,_ceeaa int )(_cggg error ){var (_aeb ,_bbaf ,_afee ,_efgc ,_fda ,_fea ,_fba ,_bebf int ;_abe ,_fc uint32 ;_adeg ,_cde byte ;_egf uint16 ;);_gfce :=make ([]byte ,4);_cggd :=make ([]byte ,4);for _afee =0;_afee < _ffe .Height -1;
_afee ,_efgc =_afee +2,_efgc +1{_aeb =_afee *_ffe .BytesPerLine ;_bbaf =_efgc *_gbf .BytesPerLine ;for _fda ,_fea =0,0;_fda < _ceeaa ;_fda ,_fea =_fda +4,_fea +1{for _fba =0;_fba < 4;_fba ++{_bebf =_aeb +_fda +_fba ;if _bebf <=len (_ffe .Data )-1&&_bebf < _aeb +_ffe .BytesPerLine {_gfce [_fba ]=_ffe .Data [_bebf ];
}else {_gfce [_fba ]=0x00;};_bebf =_aeb +_ffe .BytesPerLine +_fda +_fba ;if _bebf <=len (_ffe .Data )-1&&_bebf < _aeb +(2*_ffe .BytesPerLine ){_cggd [_fba ]=_ffe .Data [_bebf ];}else {_cggd [_fba ]=0x00;};};_abe =_ba .BigEndian .Uint32 (_gfce );_fc =_ba .BigEndian .Uint32 (_cggd );
_fc &=_abe ;_fc &=_fc <<1;_fc &=0xaaaaaaaa;_abe =_fc |(_fc <<7);_adeg =byte (_abe >>24);_cde =byte ((_abe >>8)&0xff);_bebf =_bbaf +_fea ;if _bebf +1==len (_gbf .Data )-1||_bebf +1>=_bbaf +_gbf .BytesPerLine {_gbf .Data [_bebf ]=_edc [_adeg ];if _cggg =_gbf .setByte (_bebf ,_edc [_adeg ]);
_cggg !=nil {return _ge .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_bebf );};}else {_egf =(uint16 (_edc [_adeg ])<<8)|uint16 (_edc [_cde ]);if _cggg =_gbf .setTwoBytes (_bebf ,_egf );_cggg !=nil {return _ge .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_bebf );
};_fea ++;};};};return nil ;};var ErrInvalidImage =_g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
func ConverterFunc (converterFunc func (_cae _ee .Image )(Image ,error ))ColorConverter {return colorConverter {_edb :converterFunc };};func (_ccg *Monochrome )Validate ()error {if len (_ccg .Data )!=_ccg .Height *_ccg .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func _daba (_bfbc _b .NRGBA64 )_b .Gray {var _caeb _b .NRGBA64 ;if _bfbc ==_caeb {return _b .Gray {Y :0xff};};_cdf ,_edbf ,_aab ,_ :=_bfbc .RGBA ();_fgfe :=(19595*_cdf +38470*_edbf +7471*_aab +1<<15)>>24;return _b .Gray {Y :uint8 (_fgfe )};
};func _ccdgb (_aaca _b .Color )_b .Color {_ffgd :=_b .GrayModel .Convert (_aaca ).(_b .Gray );return _dbda (_ffgd );};func ColorAtCMYK (x ,y ,width int ,data []byte ,decode []float64 )(_b .CMYK ,error ){_fag :=4*(y *width +x );if _fag +3>=len (data ){return _b .CMYK {},_ge .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};C :=data [_fag ]&0xff;M :=data [_fag +1]&0xff;Y :=data [_fag +2]&0xff;K :=data [_fag +3]&0xff;if len (decode )==8{C =uint8 (uint32 (LinearInterpolate (float64 (C ),0,255,decode [0],decode [1]))&0xff);M =uint8 (uint32 (LinearInterpolate (float64 (M ),0,255,decode [2],decode [3]))&0xff);
Y =uint8 (uint32 (LinearInterpolate (float64 (Y ),0,255,decode [4],decode [5]))&0xff);K =uint8 (uint32 (LinearInterpolate (float64 (K ),0,255,decode [6],decode [7]))&0xff);};return _b .CMYK {C :C ,M :M ,Y :Y ,K :K },nil ;};func (_agbec *Gray8 )Copy ()Image {return &Gray8 {ImageBase :_agbec .copy ()}};
func (_eed monochromeModel )Convert (c _b .Color )_b .Color {_gdb :=_b .GrayModel .Convert (c ).(_b .Gray );return _cce (_gdb ,_eed );};func (_add *ImageBase )copy ()ImageBase {_ddef :=*_add ;_ddef .Data =make ([]byte ,len (_add .Data ));copy (_ddef .Data ,_add .Data );
return _ddef ;};func (_dcec *CMYK32 )CMYKAt (x ,y int )_b .CMYK {_dab ,_ :=ColorAtCMYK (x ,y ,_dcec .Width ,_dcec .Data ,_dcec .Decode );return _dab ;};func (_cecdg *NRGBA32 )Bounds ()_ee .Rectangle {return _ee .Rectangle {Max :_ee .Point {X :_cecdg .Width ,Y :_cecdg .Height }};
};func (_efb colorConverter )Convert (src _ee .Image )(Image ,error ){return _efb ._edb (src )};func (_afedg *NRGBA64 )At (x ,y int )_b .Color {_accg ,_ :=_afedg .ColorAt (x ,y );return _accg };func _gafb (){for _ggfe :=0;_ggfe < 256;_ggfe ++{_fbaf [_ggfe ]=uint8 (_ggfe &0x1)+(uint8 (_ggfe >>1)&0x1)+(uint8 (_ggfe >>2)&0x1)+(uint8 (_ggfe >>3)&0x1)+(uint8 (_ggfe >>4)&0x1)+(uint8 (_ggfe >>5)&0x1)+(uint8 (_ggfe >>6)&0x1)+(uint8 (_ggfe >>7)&0x1);
};};func (_gacgbd *NRGBA16 )ColorModel ()_b .Model {return NRGBA16Model };func (_cdcc *CMYK32 )Bounds ()_ee .Rectangle {return _ee .Rectangle {Max :_ee .Point {X :_cdcc .Width ,Y :_cdcc .Height }};};func (_fdg *Monochrome )Scale (scale float64 )(*Monochrome ,error ){var _acdg bool ;
_ebcg :=scale ;if scale < 1{_ebcg =1/scale ;_acdg =true ;};_cgae :=NextPowerOf2 (uint (_ebcg ));if InDelta (float64 (_cgae ),_ebcg ,0.001){if _acdg {return _fdg .ReduceBinary (_ebcg );};return _fdg .ExpandBinary (int (_cgae ));};_abee :=int (_a .RoundToEven (float64 (_fdg .Width )*scale ));
_eff :=int (_a .RoundToEven (float64 (_fdg .Height )*scale ));return _fdg .ScaleLow (_abee ,_eff );};var _ Image =&Gray2 {};func _abcc (_cbg _b .RGBA )_b .NRGBA {switch _cbg .A {case 0xff:return _b .NRGBA {R :_cbg .R ,G :_cbg .G ,B :_cbg .B ,A :0xff};case 0x00:return _b .NRGBA {};
default:_cga ,_afef ,_cc ,_ccb :=_cbg .RGBA ();_cga =(_cga *0xffff)/_ccb ;_afef =(_afef *0xffff)/_ccb ;_cc =(_cc *0xffff)/_ccb ;return _b .NRGBA {R :uint8 (_cga >>8),G :uint8 (_afef >>8),B :uint8 (_cc >>8),A :uint8 (_ccb >>8)};};};func _gf (_be *Monochrome ,_dd int )(*Monochrome ,error ){if _be ==nil {return nil ,_g .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _dd ==1{return _be .copy (),nil ;};if !IsPowerOf2 (uint (_dd )){return nil ,_ge .Errorf ("\u0070\u0072\u006fvi\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006ci\u0064 \u0065x\u0070a\u006e\u0064\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",_dd );
};_fd :=_bca (_dd );return _ab (_be ,_dd ,_fd );};func (_gddc *Monochrome )Base ()*ImageBase {return &_gddc .ImageBase };func (_dbag *Monochrome )Histogram ()(_dgfb [256]int ){for _ ,_agg :=range _dbag .Data {_dgfb [0xff]+=int (_fbaf [_dbag .Data [_agg ]]);
};return _dgfb ;};func (_cbag *NRGBA16 )setNRGBA (_bggg ,_ffgbf ,_ggde int ,_eebe _b .NRGBA ){if _bggg *3%2==0{_cbag .Data [_ggde ]=(_eebe .R >>4)<<4|(_eebe .G >>4);_cbag .Data [_ggde +1]=(_eebe .B >>4)<<4|(_cbag .Data [_ggde +1]&0xf);}else {_cbag .Data [_ggde ]=(_cbag .Data [_ggde ]&0xf0)|(_eebe .R >>4);
_cbag .Data [_ggde +1]=(_eebe .G >>4)<<4|(_eebe .B >>4);};if _cbag .Alpha !=nil {_ecddg :=_ffgbf *BytesPerLine (_cbag .Width ,4,1);if _ecddg < len (_cbag .Alpha ){if _bggg %2==0{_cbag .Alpha [_ecddg ]=(_eebe .A >>uint (4))<<uint (4)|(_cbag .Alpha [_ggde ]&0xf);
}else {_cbag .Alpha [_ecddg ]=(_cbag .Alpha [_ecddg ]&0xf0)|(_eebe .A >>uint (4));};};};};func _cbdf (_bgee _b .NRGBA )_b .CMYK {_dca ,_dgc ,_ceb ,_ :=_bgee .RGBA ();_eceg ,_gdd ,_dbgg ,_aag :=_b .RGBToCMYK (uint8 (_dca >>8),uint8 (_dgc >>8),uint8 (_ceb >>8));
return _b .CMYK {C :_eceg ,M :_gdd ,Y :_dbgg ,K :_aag };};func (_fce *RGBA32 )Base ()*ImageBase {return &_fce .ImageBase };const (PixSrc RasterOperator =0xc;PixDst RasterOperator =0xa;PixNotSrc RasterOperator =0x3;PixNotDst RasterOperator =0x5;PixClr RasterOperator =0x0;
PixSet RasterOperator =0xf;PixSrcOrDst RasterOperator =0xe;PixSrcAndDst RasterOperator =0x8;PixSrcXorDst RasterOperator =0x6;PixNotSrcOrDst RasterOperator =0xb;PixNotSrcAndDst RasterOperator =0x2;PixSrcOrNotDst RasterOperator =0xd;PixSrcAndNotDst RasterOperator =0x4;
PixNotPixSrcOrDst RasterOperator =0x1;PixNotPixSrcAndDst RasterOperator =0x7;PixNotPixSrcXorDst RasterOperator =0x9;PixPaint =PixSrcOrDst ;PixSubtract =PixNotSrcAndDst ;PixMask =PixSrcAndDst ;);func _bcd (_efac Gray ,_bcda CMYK ,_egfb _ee .Rectangle ){for _fdd :=0;
_fdd < _egfb .Max .X ;_fdd ++{for _abc :=0;_abc < _egfb .Max .Y ;_abc ++{_gfac :=_efac .GrayAt (_fdd ,_abc );_bcda .SetCMYK (_fdd ,_abc ,_fab (_gfac ));};};};func _cddc (_dafg _b .NRGBA64 )_b .RGBA {_gga ,_ddad ,_ffed ,_fbad :=_dafg .RGBA ();return _b .RGBA {R :uint8 (_gga >>8),G :uint8 (_ddad >>8),B :uint8 (_ffed >>8),A :uint8 (_fbad >>8)};
};func _gffc (_bedd _ee .Image ,_aggd uint8 )*_ee .Gray {_bef :=_bedd .Bounds ();_ffbbed :=_ee .NewGray (_bef );var (_bfgc _b .Color ;_aadg _b .Gray ;);for _dgfd :=0;_dgfd < _bef .Max .X ;_dgfd ++{for _ccgdf :=0;_ccgdf < _bef .Max .Y ;_ccgdf ++{_bfgc =_bedd .At (_dgfd ,_ccgdf );
_ffbbed .Set (_dgfd ,_ccgdf ,_bfgc );_aadg =_ffbbed .GrayAt (_dgfd ,_ccgdf );_ffbbed .SetGray (_dgfd ,_ccgdf ,_b .Gray {Y :_gdgg (_aadg .Y ,_aggd )});};};return _ffbbed ;};func ColorAtNRGBA16 (x ,y ,width ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_b .NRGBA ,error ){_adge :=y *bytesPerLine +x *3/2;
if _adge +1>=len (data ){return _b .NRGBA {},_fdfb (x ,y );};const (_fbcd =0xf;_cfad =uint8 (0xff););_ceff :=_cfad ;if alpha !=nil {_gfdc :=y *BytesPerLine (width ,4,1);if _gfdc < len (alpha ){if x %2==0{_ceff =(alpha [_gfdc ]>>uint (4))&_fbcd ;}else {_ceff =alpha [_gfdc ]&_fbcd ;
};_ceff |=_ceff <<4;};};var _fcbad ,_gdfg ,_bbg uint8 ;if x *3%2==0{_fcbad =(data [_adge ]>>uint (4))&_fbcd ;_gdfg =data [_adge ]&_fbcd ;_bbg =(data [_adge +1]>>uint (4))&_fbcd ;}else {_fcbad =data [_adge ]&_fbcd ;_gdfg =(data [_adge +1]>>uint (4))&_fbcd ;
_bbg =data [_adge +1]&_fbcd ;};if len (decode )==6{_fcbad =uint8 (uint32 (LinearInterpolate (float64 (_fcbad ),0,15,decode [0],decode [1]))&0xf);_gdfg =uint8 (uint32 (LinearInterpolate (float64 (_gdfg ),0,15,decode [2],decode [3]))&0xf);_bbg =uint8 (uint32 (LinearInterpolate (float64 (_bbg ),0,15,decode [4],decode [5]))&0xf);
};return _b .NRGBA {R :(_fcbad <<4)|(_fcbad &0xf),G :(_gdfg <<4)|(_gdfg &0xf),B :(_bbg <<4)|(_bbg &0xf),A :_ceff },nil ;};func InDelta (expected ,current ,delta float64 )bool {_acc :=expected -current ;if _acc <=-delta ||_acc >=delta {return false ;};return true ;
};func (_ddb *ImageBase )HasAlpha ()bool {if _ddb .Alpha ==nil {return false ;};for _bafg :=range _ddb .Alpha {if _ddb .Alpha [_bafg ]!=0xff{return true ;};};return false ;};var _ Image =&CMYK32 {};func (_bdbf *NRGBA64 )Validate ()error {if len (_bdbf .Data )!=3*2*_bdbf .Width *_bdbf .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};var _ Gray =&Gray2 {};func _gegd (_ddcd NRGBA ,_bggf Gray ,_eegd _ee .Rectangle ){for _dcaf :=0;_dcaf < _eegd .Max .X ;_dcaf ++{for _ggaa :=0;_ggaa < _eegd .Max .Y ;_ggaa ++{_dbfd :=_ggfb (_ddcd .NRGBAAt (_dcaf ,_ggaa ));_bggf .SetGray (_dcaf ,_ggaa ,_dbfd );
};};};func (_faae *NRGBA64 )Base ()*ImageBase {return &_faae .ImageBase };func ColorAtGray2BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_acfc :=y *bytesPerLine +x >>2;if _acfc >=len (data ){return _b .Gray {},_ge .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_gfg :=data [_acfc ]>>uint (6-(x &3)*2)&3;if len (decode )==2{_gfg =uint8 (uint32 (LinearInterpolate (float64 (_gfg ),0,3.0,decode [0],decode [1]))&3);};return _b .Gray {Y :_gfg *85},nil ;};func (_ecee *Gray8 )Histogram ()(_ccef [256]int ){for _efdbb :=0;
_efdbb < len (_ecee .Data );_efdbb ++{_ccef [_ecee .Data [_efdbb ]]++;};return _ccef ;};func (_dbb *CMYK32 )Base ()*ImageBase {return &_dbb .ImageBase };func (_ded *Gray4 )Copy ()Image {return &Gray4 {ImageBase :_ded .copy ()}};var (Gray2Model =_b .ModelFunc (_ccdgb );
Gray4Model =_b .ModelFunc (_caf );NRGBA16Model =_b .ModelFunc (_gfda ););func ColorAtGray16BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray16 ,error ){_gdge :=(y *bytesPerLine /2+x )*2;if _gdge +1>=len (data ){return _b .Gray16 {},_ge .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dcgb :=uint16 (data [_gdge ])<<8|uint16 (data [_gdge +1]);if len (decode )==2{_dcgb =uint16 (uint64 (LinearInterpolate (float64 (_dcgb ),0,65535,decode [0],decode [1])));};return _b .Gray16 {Y :_dcgb },nil ;};var _ _ee .Image =&Gray16 {};func (_cabd *Gray4 )Base ()*ImageBase {return &_cabd .ImageBase };
var _ Image =&RGBA32 {};func _cdcb (_feg _b .CMYK )_b .RGBA {_gecc ,_ecd ,_bdf :=_b .CMYKToRGB (_feg .C ,_feg .M ,_feg .Y ,_feg .K );return _b .RGBA {R :_gecc ,G :_ecd ,B :_bdf ,A :0xff};};type monochromeThresholdConverter struct{Threshold uint8 ;};func (_gge *Gray4 )setGray (_cbfc int ,_cgcd int ,_adgc _b .Gray ){_dgd :=_cgcd *_gge .BytesPerLine ;
_aaae :=_dgd +(_cbfc >>1);if _aaae >=len (_gge .Data ){return ;};_gddd :=_adgc .Y >>4;_gge .Data [_aaae ]=(_gge .Data [_aaae ]&(^(0xf0>>uint (4*(_cbfc &1)))))|(_gddd <<uint (4-4*(_cbfc &1)));};func ScaleAlphaToMonochrome (data []byte ,width ,height int )([]byte ,error ){_eg :=BytesPerLine (width ,8,1);
if len (data )< _eg *height {return nil ,nil ;};_ga :=&Gray8 {NewImageBase (width ,height ,8,1,data ,nil ,nil )};_ae ,_ad :=MonochromeConverter .Convert (_ga );if _ad !=nil {return nil ,_ad ;};return _ae .Base ().Data ,nil ;};func (_beefc *Gray2 )ColorModel ()_b .Model {return Gray2Model };
func init (){_gafb ()};func _gead (_aad Gray ,_ccdg NRGBA ,_feag _ee .Rectangle ){for _fca :=0;_fca < _feag .Max .X ;_fca ++{for _dbde :=0;_dbde < _feag .Max .Y ;_dbde ++{_dadd :=_ffd (_ccdg .NRGBAAt (_fca ,_dbde ));_aad .SetGray (_fca ,_dbde ,_dadd );
};};};func (_cdbd *RGBA32 )SetRGBA (x ,y int ,c _b .RGBA ){_gdbe :=y *_cdbd .Width +x ;_abfd :=3*_gdbe ;if _abfd +2>=len (_cdbd .Data ){return ;};_cdbd .setRGBA (_gdbe ,c );};func (_eca *CMYK32 )Set (x ,y int ,c _b .Color ){_adea :=4*(y *_eca .Width +x );
if _adea +3>=len (_eca .Data ){return ;};_abbd :=_b .CMYKModel .Convert (c ).(_b .CMYK );_eca .Data [_adea ]=_abbd .C ;_eca .Data [_adea +1]=_abbd .M ;_eca .Data [_adea +2]=_abbd .Y ;_eca .Data [_adea +3]=_abbd .K ;};var _ _ee .Image =&NRGBA64 {};func (_cabg *Monochrome )Set (x ,y int ,c _b .Color ){_dgf :=y *_cabg .BytesPerLine +x >>3;
if _dgf > len (_cabg .Data )-1{return ;};_cdgf :=_cabg .ColorModel ().Convert (c ).(_b .Gray );_cabg .setGray (x ,_cdgf ,_dgf );};func (_fec *ImageBase )setEightPartlyBytes (_cfgbg ,_fdb int ,_efda uint64 )(_gceg error ){var (_bead byte ;_aedf int ;);for _bddg :=1;
_bddg <=_fdb ;_bddg ++{_aedf =64-_bddg *8;_bead =byte (_efda >>uint (_aedf )&0xff);if _gceg =_fec .setByte (_cfgbg +_bddg -1,_bead );_gceg !=nil {return _gceg ;};};_gacb :=_fec .BytesPerLine *8-_fec .Width ;if _gacb ==0{return nil ;};_aedf -=8;_bead =byte (_efda >>uint (_aedf )&0xff)<<uint (_gacb );
if _gceg =_fec .setByte (_cfgbg +_fdb ,_bead );_gceg !=nil {return _gceg ;};return nil ;};func _eaae (_gag _b .Gray )_b .RGBA {return _b .RGBA {R :_gag .Y ,G :_gag .Y ,B :_gag .Y ,A :0xff}};func (_gcg *NRGBA64 )SetNRGBA64 (x ,y int ,c _b .NRGBA64 ){_cded :=(y *_gcg .Width +x )*2;
_dcde :=_cded *3;if _dcde +5>=len (_gcg .Data ){return ;};_gcg .setNRGBA64 (_dcde ,c ,_cded );};func _eebda (_fbgea CMYK ,_cccg RGBA ,_cadg _ee .Rectangle ){for _abea :=0;_abea < _cadg .Max .X ;_abea ++{for _cbcd :=0;_cbcd < _cadg .Max .Y ;_cbcd ++{_bbffc :=_fbgea .CMYKAt (_abea ,_cbcd );
_cccg .SetRGBA (_abea ,_cbcd ,_cdcb (_bbffc ));};};};func _fccg (_beefg _ee .Image )(Image ,error ){if _gfgb ,_dgbb :=_beefg .(*NRGBA16 );_dgbb {return _gfgb .Copy (),nil ;};_baae :=_beefg .Bounds ();_gfe ,_eegb :=NewImage (_baae .Max .X ,_baae .Max .Y ,4,3,nil ,nil ,nil );
if _eegb !=nil {return nil ,_eegb ;};_acdc (_beefg ,_gfe ,_baae );return _gfe ,nil ;};type Gray2 struct{ImageBase };func (_efef *Gray16 )Base ()*ImageBase {return &_efef .ImageBase };func _gfda (_egge _b .Color )_b .Color {_fbga :=_b .NRGBAModel .Convert (_egge ).(_b .NRGBA );
return _cfdc (_fbga );};var _fbaf [256]uint8 ;func NewImageBase (width int ,height int ,bitsPerComponent int ,colorComponents int ,data []byte ,alpha []byte ,decode []float64 )ImageBase {_dcgg :=ImageBase {Width :width ,Height :height ,BitsPerComponent :bitsPerComponent ,ColorComponents :colorComponents ,Data :data ,Alpha :alpha ,Decode :decode ,BytesPerLine :BytesPerLine (width ,bitsPerComponent ,colorComponents )};
if data ==nil {_dcgg .Data =make ([]byte ,height *_dcgg .BytesPerLine );};return _dcgg ;};func _ddga (_adc *Monochrome ,_da ...int )(_eda *Monochrome ,_bbf error ){if _adc ==nil {return nil ,_g .New ("\u0073o\u0075\u0072\u0063\u0065 \u0062\u0069\u0074\u006d\u0061p\u0020n\u006ft\u0020\u0064\u0065\u0066\u0069\u006e\u0065d");
};if len (_da )==0{return nil ,_g .New ("\u0074h\u0065\u0072e\u0020\u006d\u0075s\u0074\u0020\u0062\u0065\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u006c\u0065\u0076\u0065\u006c\u0020\u006f\u0066 \u0072\u0065\u0064\u0075\u0063\u0074\u0069\u006f\u006e");
};_bgc :=_feb ();_eda =_adc ;for _ ,_edgd :=range _da {if _edgd <=0{break ;};_eda ,_bbf =_ebb (_eda ,_edgd ,_bgc );if _bbf !=nil {return nil ,_bbf ;};};return _eda ,nil ;};type RGBA interface{RGBAAt (_cdfga ,_fdfag int )_b .RGBA ;SetRGBA (_bccd ,_fdfab int ,_ddcf _b .RGBA );
};func _bde (_egb ,_gac *Monochrome ,_eef []byte ,_eab int )(_ade error ){var (_gbd ,_bcgb ,_eaf ,_cea ,_df ,_afg ,_faf ,_aa int ;_gda ,_ebg uint32 ;_eeg ,_ega byte ;_aaf uint16 ;);_bea :=make ([]byte ,4);_agcc :=make ([]byte ,4);for _eaf =0;_eaf < _egb .Height -1;
_eaf ,_cea =_eaf +2,_cea +1{_gbd =_eaf *_egb .BytesPerLine ;_bcgb =_cea *_gac .BytesPerLine ;for _df ,_afg =0,0;_df < _eab ;_df ,_afg =_df +4,_afg +1{for _faf =0;_faf < 4;_faf ++{_aa =_gbd +_df +_faf ;if _aa <=len (_egb .Data )-1&&_aa < _gbd +_egb .BytesPerLine {_bea [_faf ]=_egb .Data [_aa ];
}else {_bea [_faf ]=0x00;};_aa =_gbd +_egb .BytesPerLine +_df +_faf ;if _aa <=len (_egb .Data )-1&&_aa < _gbd +(2*_egb .BytesPerLine ){_agcc [_faf ]=_egb .Data [_aa ];}else {_agcc [_faf ]=0x00;};};_gda =_ba .BigEndian .Uint32 (_bea );_ebg =_ba .BigEndian .Uint32 (_agcc );
_ebg |=_gda ;_ebg |=_ebg <<1;_ebg &=0xaaaaaaaa;_gda =_ebg |(_ebg <<7);_eeg =byte (_gda >>24);_ega =byte ((_gda >>8)&0xff);_aa =_bcgb +_afg ;if _aa +1==len (_gac .Data )-1||_aa +1>=_bcgb +_gac .BytesPerLine {_gac .Data [_aa ]=_eef [_eeg ];}else {_aaf =(uint16 (_eef [_eeg ])<<8)|uint16 (_eef [_ega ]);
if _ade =_gac .setTwoBytes (_aa ,_aaf );_ade !=nil {return _ge .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_aa );
};_afg ++;};};};return nil ;};func (_ggfc *CMYK32 )Copy ()Image {return &CMYK32 {ImageBase :_ggfc .copy ()}};func (_fddga *Gray16 )ColorModel ()_b .Model {return _b .Gray16Model };func (_beada *RGBA32 )Set (x ,y int ,c _b .Color ){_bfe :=y *_beada .Width +x ;
_ccfb :=3*_bfe ;if _ccfb +2>=len (_beada .Data ){return ;};_afga :=_b .RGBAModel .Convert (c ).(_b .RGBA );_beada .setRGBA (_bfe ,_afga );};func (_fedf *RGBA32 )Validate ()error {if len (_fedf .Data )!=3*_fedf .Width *_fedf .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _efdf (_gab _b .Gray )_b .Gray {_gab .Y >>=4;_gab .Y |=_gab .Y <<4;return _gab };func _ea (_eba ,_dcfd *Monochrome )(_ege error ){_ead :=_dcfd .BytesPerLine ;_ceg :=_eba .BytesPerLine ;var _cba ,_adb ,_gd ,_acd ,_db int ;for _gd =0;
_gd < _dcfd .Height ;_gd ++{_cba =_gd *_ead ;_adb =8*_gd *_ceg ;for _acd =0;_acd < _ead ;_acd ++{if _ege =_eba .setEightBytes (_adb +_acd *8,_eaa [_dcfd .Data [_cba +_acd ]]);_ege !=nil {return _ege ;};};for _db =1;_db < 8;_db ++{for _acd =0;_acd < _ceg ;
_acd ++{if _ege =_eba .setByte (_adb +_db *_ceg +_acd ,_eba .Data [_adb +_acd ]);_ege !=nil {return _ege ;};};};};return nil ;};func (_fegg *Gray4 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray4BPC (x ,y ,_fegg .BytesPerLine ,_fegg .Data ,_fegg .Decode );
};func (_gbbb *Monochrome )SetGray (x ,y int ,g _b .Gray ){_bee :=y *_gbbb .BytesPerLine +x >>3;if _bee > len (_gbbb .Data )-1{return ;};g =_cce (g ,monochromeModel (_gbbb .ModelThreshold ));_gbbb .setGray (x ,g ,_bee );};func _eee (_aefb CMYK ,_ccdgg Gray ,_cebg _ee .Rectangle ){for _bcfe :=0;
_bcfe < _cebg .Max .X ;_bcfe ++{for _geadc :=0;_geadc < _cebg .Max .Y ;_geadc ++{_bccc :=_aceg (_aefb .CMYKAt (_bcfe ,_geadc ));_ccdgg .SetGray (_bcfe ,_geadc ,_bccc );};};};func (_bbdb *Gray2 )GrayAt (x ,y int )_b .Gray {_cbbf ,_ :=ColorAtGray2BPC (x ,y ,_bbdb .BytesPerLine ,_bbdb .Data ,_bbdb .Decode );
return _cbbf ;};func (_fggff *Gray8 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray8BPC (x ,y ,_fggff .BytesPerLine ,_fggff .Data ,_fggff .Decode );};var _ Image =&Gray16 {};func (_cggc *Monochrome )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray1BPC (x ,y ,_cggc .BytesPerLine ,_cggc .Data ,_cggc .Decode );
};func _cfdc (_feda _b .NRGBA )_b .NRGBA {_feda .R =_feda .R >>4|(_feda .R >>4)<<4;_feda .G =_feda .G >>4|(_feda .G >>4)<<4;_feda .B =_feda .B >>4|(_feda .B >>4)<<4;return _feda ;};func _gbe ()(_bc [256]uint16 ){for _bff :=0;_bff < 256;_bff ++{if _bff &0x01!=0{_bc [_bff ]|=0x3;
};if _bff &0x02!=0{_bc [_bff ]|=0xc;};if _bff &0x04!=0{_bc [_bff ]|=0x30;};if _bff &0x08!=0{_bc [_bff ]|=0xc0;};if _bff &0x10!=0{_bc [_bff ]|=0x300;};if _bff &0x20!=0{_bc [_bff ]|=0xc00;};if _bff &0x40!=0{_bc [_bff ]|=0x3000;};if _bff &0x80!=0{_bc [_bff ]|=0xc000;
};};return _bc ;};func (_gege *Gray8 )At (x ,y int )_b .Color {_ddgc ,_ :=_gege .ColorAt (x ,y );return _ddgc };type monochromeModel uint8 ;func (_ccba *NRGBA32 )Copy ()Image {return &NRGBA32 {ImageBase :_ccba .copy ()}};func ColorAtNRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_b .NRGBA ,error ){_cfde :=y *width +x ;
_fdab :=3*_cfde ;if _fdab +2>=len (data ){return _b .NRGBA {},_ge .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_ggb :=uint8 (0xff);if alpha !=nil &&len (alpha )> _cfde {_ggb =alpha [_cfde ];};_fcde ,_cbgdg ,_fgda :=data [_fdab ],data [_fdab +1],data [_fdab +2];if len (decode )==6{_fcde =uint8 (uint32 (LinearInterpolate (float64 (_fcde ),0,255,decode [0],decode [1]))&0xff);
_cbgdg =uint8 (uint32 (LinearInterpolate (float64 (_cbgdg ),0,255,decode [2],decode [3]))&0xff);_fgda =uint8 (uint32 (LinearInterpolate (float64 (_fgda ),0,255,decode [4],decode [5]))&0xff);};return _b .NRGBA {R :_fcde ,G :_cbgdg ,B :_fgda ,A :_ggb },nil ;
};func (_feab *Gray8 )SetGray (x ,y int ,g _b .Gray ){_ccdgd :=y *_feab .BytesPerLine +x ;if _ccdgd > len (_feab .Data )-1{return ;};_feab .Data [_ccdgd ]=g .Y ;};func _ggfb (_bdd _b .NRGBA )_b .Gray {_gbgd ,_acf ,_ffada ,_ :=_bdd .RGBA ();_gagf :=(19595*_gbgd +38470*_acf +7471*_ffada +1<<15)>>24;
return _b .Gray {Y :uint8 (_gagf )};};var _ Gray =&Gray8 {};func (_bcgd *Monochrome )Copy ()Image {return &Monochrome {ImageBase :_bcgd .ImageBase .copy (),ModelThreshold :_bcgd .ModelThreshold };};func (_adbbc *ImageBase )setTwoBytes (_gggd int ,_gadf uint16 )error {if _gggd +1> len (_adbbc .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_adbbc .Data [_gggd ]=byte ((_gadf &0xff00)>>8);_adbbc .Data [_gggd +1]=byte (_gadf &0xff);return nil ;};var _ _ee .Image =&NRGBA16 {};func ColorAtGray4BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_dbcd :=y *bytesPerLine +x >>1;
if _dbcd >=len (data ){return _b .Gray {},_ge .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_fgcd :=data [_dbcd ]>>uint (4-(x &1)*4)&0xf;if len (decode )==2{_fgcd =uint8 (uint32 (LinearInterpolate (float64 (_fgcd ),0,15,decode [0],decode [1]))&0xf);};return _b .Gray {Y :_fgcd *17&0xff},nil ;};type colorConverter struct{_edb func (_dbd _ee .Image )(Image ,error );
};func _acdc (_dgec _ee .Image ,_agga Image ,_geddc _ee .Rectangle ){if _fcacd ,_aebec :=_dgec .(SMasker );_aebec &&_fcacd .HasAlpha (){_agga .(SMasker ).MakeAlpha ();};switch _defe :=_dgec .(type ){case Gray :_egcbd (_defe ,_agga .(NRGBA ),_geddc );case NRGBA :_ececb (_defe ,_agga .(NRGBA ),_geddc );
case *_ee .NYCbCrA :_feadc (_defe ,_agga .(NRGBA ),_geddc );case CMYK :_cgfgd (_defe ,_agga .(NRGBA ),_geddc );case RGBA :_affc (_defe ,_agga .(NRGBA ),_geddc );case nrgba64 :_eedf (_defe ,_agga .(NRGBA ),_geddc );default:_agbc (_dgec ,_agga ,_geddc );
};};type nrgba64 interface{NRGBA64At (_adgef ,_efbf int )_b .NRGBA64 ;SetNRGBA64 (_dded ,_cffb int ,_acca _b .NRGBA64 );};func _ada (_ac ,_dg *Monochrome )(_fe error ){_dcf :=_dg .BytesPerLine ;_dcg :=_ac .BytesPerLine ;_aff :=_dg .BytesPerLine *4-_ac .BytesPerLine ;
var (_ffbf ,_dge byte ;_fb uint32 ;_bf ,_ce ,_edg ,_cbb ,_ca ,_bfd ,_afe int ;);for _edg =0;_edg < _dg .Height ;_edg ++{_bf =_edg *_dcf ;_ce =4*_edg *_dcg ;for _cbb =0;_cbb < _dcf ;_cbb ++{_ffbf =_dg .Data [_bf +_cbb ];_fb =_edge [_ffbf ];_bfd =_ce +_cbb *4;
if _aff !=0&&(_cbb +1)*4> _ac .BytesPerLine {for _ca =_aff ;_ca > 0;_ca --{_dge =byte ((_fb >>uint (_ca *8))&0xff);_afe =_bfd +(_aff -_ca );if _fe =_ac .setByte (_afe ,_dge );_fe !=nil {return _fe ;};};}else if _fe =_ac .setFourBytes (_bfd ,_fb );_fe !=nil {return _fe ;
};if _fe =_ac .setFourBytes (_ce +_cbb *4,_edge [_dg .Data [_bf +_cbb ]]);_fe !=nil {return _fe ;};};for _ca =1;_ca < 4;_ca ++{for _cbb =0;_cbb < _dcg ;_cbb ++{if _fe =_ac .setByte (_ce +_ca *_dcg +_cbb ,_ac .Data [_ce +_cbb ]);_fe !=nil {return _fe ;};
};};};return nil ;};func _bge (_egbf NRGBA ,_fcb CMYK ,_ebbc _ee .Rectangle ){for _gfdd :=0;_gfdd < _ebbc .Max .X ;_gfdd ++{for _gdc :=0;_gdc < _ebbc .Max .Y ;_gdc ++{_bag :=_egbf .NRGBAAt (_gfdd ,_gdc );_fcb .SetCMYK (_gfdd ,_gdc ,_cbdf (_bag ));};};};
var _ NRGBA =&NRGBA16 {};func _afag (_gaac *Monochrome ,_egcc ,_daca ,_aeeb ,_ebd int ,_bfaf RasterOperator ,_feacg *Monochrome ,_dgbcd ,_ccbc int )error {var (_ceaf bool ;_gdef bool ;_eefe int ;_bacb int ;_eecf int ;_acff bool ;_agbce byte ;_faaa int ;
_caaef int ;_ecece int ;_ddd ,_dgaa int ;);_abccf :=8-(_egcc &7);_gdcc :=_eafb [_abccf ];_fcacb :=_gaac .BytesPerLine *_daca +(_egcc >>3);_aecc :=_feacg .BytesPerLine *_ccbc +(_dgbcd >>3);if _aeeb < _abccf {_ceaf =true ;_gdcc &=_gedd [8-_abccf +_aeeb ];
};if !_ceaf {_eefe =(_aeeb -_abccf )>>3;if _eefe > 0{_gdef =true ;_bacb =_fcacb +1;_eecf =_aecc +1;};};_faaa =(_egcc +_aeeb )&7;if !(_ceaf ||_faaa ==0){_acff =true ;_agbce =_gedd [_faaa ];_caaef =_fcacb +1+_eefe ;_ecece =_aecc +1+_eefe ;};switch _bfaf {case PixSrc :for _ddd =0;
_ddd < _ebd ;_ddd ++{_gaac .Data [_fcacb ]=_dabg (_gaac .Data [_fcacb ],_feacg .Data [_aecc ],_gdcc );_fcacb +=_gaac .BytesPerLine ;_aecc +=_feacg .BytesPerLine ;};if _gdef {for _ddd =0;_ddd < _ebd ;_ddd ++{for _dgaa =0;_dgaa < _eefe ;_dgaa ++{_gaac .Data [_bacb +_dgaa ]=_feacg .Data [_eecf +_dgaa ];
};_bacb +=_gaac .BytesPerLine ;_eecf +=_feacg .BytesPerLine ;};};if _acff {for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_caaef ]=_dabg (_gaac .Data [_caaef ],_feacg .Data [_ecece ],_agbce );_caaef +=_gaac .BytesPerLine ;_ecece +=_feacg .BytesPerLine ;
};};case PixNotSrc :for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_fcacb ]=_dabg (_gaac .Data [_fcacb ],^_feacg .Data [_aecc ],_gdcc );_fcacb +=_gaac .BytesPerLine ;_aecc +=_feacg .BytesPerLine ;};if _gdef {for _ddd =0;_ddd < _ebd ;_ddd ++{for _dgaa =0;
_dgaa < _eefe ;_dgaa ++{_gaac .Data [_bacb +_dgaa ]=^_feacg .Data [_eecf +_dgaa ];};_bacb +=_gaac .BytesPerLine ;_eecf +=_feacg .BytesPerLine ;};};if _acff {for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_caaef ]=_dabg (_gaac .Data [_caaef ],^_feacg .Data [_ecece ],_agbce );
_caaef +=_gaac .BytesPerLine ;_ecece +=_feacg .BytesPerLine ;};};case PixSrcOrDst :for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_fcacb ]=_dabg (_gaac .Data [_fcacb ],_feacg .Data [_aecc ]|_gaac .Data [_fcacb ],_gdcc );_fcacb +=_gaac .BytesPerLine ;_aecc +=_feacg .BytesPerLine ;
};if _gdef {for _ddd =0;_ddd < _ebd ;_ddd ++{for _dgaa =0;_dgaa < _eefe ;_dgaa ++{_gaac .Data [_bacb +_dgaa ]|=_feacg .Data [_eecf +_dgaa ];};_bacb +=_gaac .BytesPerLine ;_eecf +=_feacg .BytesPerLine ;};};if _acff {for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_caaef ]=_dabg (_gaac .Data [_caaef ],_feacg .Data [_ecece ]|_gaac .Data [_caaef ],_agbce );
_caaef +=_gaac .BytesPerLine ;_ecece +=_feacg .BytesPerLine ;};};case PixSrcAndDst :for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_fcacb ]=_dabg (_gaac .Data [_fcacb ],_feacg .Data [_aecc ]&_gaac .Data [_fcacb ],_gdcc );_fcacb +=_gaac .BytesPerLine ;_aecc +=_feacg .BytesPerLine ;
};if _gdef {for _ddd =0;_ddd < _ebd ;_ddd ++{for _dgaa =0;_dgaa < _eefe ;_dgaa ++{_gaac .Data [_bacb +_dgaa ]&=_feacg .Data [_eecf +_dgaa ];};_bacb +=_gaac .BytesPerLine ;_eecf +=_feacg .BytesPerLine ;};};if _acff {for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_caaef ]=_dabg (_gaac .Data [_caaef ],_feacg .Data [_ecece ]&_gaac .Data [_caaef ],_agbce );
_caaef +=_gaac .BytesPerLine ;_ecece +=_feacg .BytesPerLine ;};};case PixSrcXorDst :for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_fcacb ]=_dabg (_gaac .Data [_fcacb ],_feacg .Data [_aecc ]^_gaac .Data [_fcacb ],_gdcc );_fcacb +=_gaac .BytesPerLine ;_aecc +=_feacg .BytesPerLine ;
};if _gdef {for _ddd =0;_ddd < _ebd ;_ddd ++{for _dgaa =0;_dgaa < _eefe ;_dgaa ++{_gaac .Data [_bacb +_dgaa ]^=_feacg .Data [_eecf +_dgaa ];};_bacb +=_gaac .BytesPerLine ;_eecf +=_feacg .BytesPerLine ;};};if _acff {for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_caaef ]=_dabg (_gaac .Data [_caaef ],_feacg .Data [_ecece ]^_gaac .Data [_caaef ],_agbce );
_caaef +=_gaac .BytesPerLine ;_ecece +=_feacg .BytesPerLine ;};};case PixNotSrcOrDst :for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_fcacb ]=_dabg (_gaac .Data [_fcacb ],^(_feacg .Data [_aecc ])|_gaac .Data [_fcacb ],_gdcc );_fcacb +=_gaac .BytesPerLine ;
_aecc +=_feacg .BytesPerLine ;};if _gdef {for _ddd =0;_ddd < _ebd ;_ddd ++{for _dgaa =0;_dgaa < _eefe ;_dgaa ++{_gaac .Data [_bacb +_dgaa ]|=^(_feacg .Data [_eecf +_dgaa ]);};_bacb +=_gaac .BytesPerLine ;_eecf +=_feacg .BytesPerLine ;};};if _acff {for _ddd =0;
_ddd < _ebd ;_ddd ++{_gaac .Data [_caaef ]=_dabg (_gaac .Data [_caaef ],^(_feacg .Data [_ecece ])|_gaac .Data [_caaef ],_agbce );_caaef +=_gaac .BytesPerLine ;_ecece +=_feacg .BytesPerLine ;};};case PixNotSrcAndDst :for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_fcacb ]=_dabg (_gaac .Data [_fcacb ],^(_feacg .Data [_aecc ])&_gaac .Data [_fcacb ],_gdcc );
_fcacb +=_gaac .BytesPerLine ;_aecc +=_feacg .BytesPerLine ;};if _gdef {for _ddd =0;_ddd < _ebd ;_ddd ++{for _dgaa =0;_dgaa < _eefe ;_dgaa ++{_gaac .Data [_bacb +_dgaa ]&=^_feacg .Data [_eecf +_dgaa ];};_bacb +=_gaac .BytesPerLine ;_eecf +=_feacg .BytesPerLine ;
};};if _acff {for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_caaef ]=_dabg (_gaac .Data [_caaef ],^(_feacg .Data [_ecece ])&_gaac .Data [_caaef ],_agbce );_caaef +=_gaac .BytesPerLine ;_ecece +=_feacg .BytesPerLine ;};};case PixSrcOrNotDst :for _ddd =0;
_ddd < _ebd ;_ddd ++{_gaac .Data [_fcacb ]=_dabg (_gaac .Data [_fcacb ],_feacg .Data [_aecc ]|^(_gaac .Data [_fcacb ]),_gdcc );_fcacb +=_gaac .BytesPerLine ;_aecc +=_feacg .BytesPerLine ;};if _gdef {for _ddd =0;_ddd < _ebd ;_ddd ++{for _dgaa =0;_dgaa < _eefe ;
_dgaa ++{_gaac .Data [_bacb +_dgaa ]=_feacg .Data [_eecf +_dgaa ]|^(_gaac .Data [_bacb +_dgaa ]);};_bacb +=_gaac .BytesPerLine ;_eecf +=_feacg .BytesPerLine ;};};if _acff {for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_caaef ]=_dabg (_gaac .Data [_caaef ],_feacg .Data [_ecece ]|^(_gaac .Data [_caaef ]),_agbce );
_caaef +=_gaac .BytesPerLine ;_ecece +=_feacg .BytesPerLine ;};};case PixSrcAndNotDst :for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_fcacb ]=_dabg (_gaac .Data [_fcacb ],_feacg .Data [_aecc ]&^(_gaac .Data [_fcacb ]),_gdcc );_fcacb +=_gaac .BytesPerLine ;
_aecc +=_feacg .BytesPerLine ;};if _gdef {for _ddd =0;_ddd < _ebd ;_ddd ++{for _dgaa =0;_dgaa < _eefe ;_dgaa ++{_gaac .Data [_bacb +_dgaa ]=_feacg .Data [_eecf +_dgaa ]&^(_gaac .Data [_bacb +_dgaa ]);};_bacb +=_gaac .BytesPerLine ;_eecf +=_feacg .BytesPerLine ;
};};if _acff {for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_caaef ]=_dabg (_gaac .Data [_caaef ],_feacg .Data [_ecece ]&^(_gaac .Data [_caaef ]),_agbce );_caaef +=_gaac .BytesPerLine ;_ecece +=_feacg .BytesPerLine ;};};case PixNotPixSrcOrDst :for _ddd =0;
_ddd < _ebd ;_ddd ++{_gaac .Data [_fcacb ]=_dabg (_gaac .Data [_fcacb ],^(_feacg .Data [_aecc ]|_gaac .Data [_fcacb ]),_gdcc );_fcacb +=_gaac .BytesPerLine ;_aecc +=_feacg .BytesPerLine ;};if _gdef {for _ddd =0;_ddd < _ebd ;_ddd ++{for _dgaa =0;_dgaa < _eefe ;
_dgaa ++{_gaac .Data [_bacb +_dgaa ]=^(_feacg .Data [_eecf +_dgaa ]|_gaac .Data [_bacb +_dgaa ]);};_bacb +=_gaac .BytesPerLine ;_eecf +=_feacg .BytesPerLine ;};};if _acff {for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_caaef ]=_dabg (_gaac .Data [_caaef ],^(_feacg .Data [_ecece ]|_gaac .Data [_caaef ]),_agbce );
_caaef +=_gaac .BytesPerLine ;_ecece +=_feacg .BytesPerLine ;};};case PixNotPixSrcAndDst :for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_fcacb ]=_dabg (_gaac .Data [_fcacb ],^(_feacg .Data [_aecc ]&_gaac .Data [_fcacb ]),_gdcc );_fcacb +=_gaac .BytesPerLine ;
_aecc +=_feacg .BytesPerLine ;};if _gdef {for _ddd =0;_ddd < _ebd ;_ddd ++{for _dgaa =0;_dgaa < _eefe ;_dgaa ++{_gaac .Data [_bacb +_dgaa ]=^(_feacg .Data [_eecf +_dgaa ]&_gaac .Data [_bacb +_dgaa ]);};_bacb +=_gaac .BytesPerLine ;_eecf +=_feacg .BytesPerLine ;
};};if _acff {for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_caaef ]=_dabg (_gaac .Data [_caaef ],^(_feacg .Data [_ecece ]&_gaac .Data [_caaef ]),_agbce );_caaef +=_gaac .BytesPerLine ;_ecece +=_feacg .BytesPerLine ;};};case PixNotPixSrcXorDst :for _ddd =0;
_ddd < _ebd ;_ddd ++{_gaac .Data [_fcacb ]=_dabg (_gaac .Data [_fcacb ],^(_feacg .Data [_aecc ]^_gaac .Data [_fcacb ]),_gdcc );_fcacb +=_gaac .BytesPerLine ;_aecc +=_feacg .BytesPerLine ;};if _gdef {for _ddd =0;_ddd < _ebd ;_ddd ++{for _dgaa =0;_dgaa < _eefe ;
_dgaa ++{_gaac .Data [_bacb +_dgaa ]=^(_feacg .Data [_eecf +_dgaa ]^_gaac .Data [_bacb +_dgaa ]);};_bacb +=_gaac .BytesPerLine ;_eecf +=_feacg .BytesPerLine ;};};if _acff {for _ddd =0;_ddd < _ebd ;_ddd ++{_gaac .Data [_caaef ]=_dabg (_gaac .Data [_caaef ],^(_feacg .Data [_ecece ]^_gaac .Data [_caaef ]),_agbce );
_caaef +=_gaac .BytesPerLine ;_ecece +=_feacg .BytesPerLine ;};};default:_d .Log .Debug ("I\u006e\u0076\u0061\u006c\u0069\u0064 \u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070e\u0072\u0061\u0074o\u0072:\u0020\u0025\u0064",_bfaf );return _g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");
};return nil ;};func GetConverter (bitsPerComponent ,colorComponents int )(ColorConverter ,error ){switch colorComponents {case 1:switch bitsPerComponent {case 1:return MonochromeConverter ,nil ;case 2:return Gray2Converter ,nil ;case 4:return Gray4Converter ,nil ;
case 8:return GrayConverter ,nil ;case 16:return Gray16Converter ,nil ;};case 3:switch bitsPerComponent {case 4:return NRGBA16Converter ,nil ;case 8:return NRGBAConverter ,nil ;case 16:return NRGBA64Converter ,nil ;};case 4:return CMYKConverter ,nil ;};
return nil ,_ge .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u0063\u006f\u006c\u006f\u0072\u0043o\u006e\u0076\u0065\u0072\u0074\u0065\u0072\u0020\u0070\u0061\u0072\u0061\u006d\u0065t\u0065\u0072\u0073\u002e\u0020\u0042\u0069\u0074\u0073\u0050\u0065\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006e\u0074\u003a\u0020\u0025\u0064\u002c\u0020\u0043\u006f\u006co\u0072\u0043\u006f\u006d\u0070\u006f\u006e\u0065\u006et\u0073\u003a \u0025\u0064",bitsPerComponent ,colorComponents );
};func (_dbc *Gray2 )Base ()*ImageBase {return &_dbc .ImageBase };var _ _ee .Image =&Monochrome {};var _ Image =&Gray8 {};func (_cdeb *Monochrome )setGrayBit (_gfaa ,_baga int ){_cdeb .Data [_gfaa ]|=0x80>>uint (_baga &7)};var _ Gray =&Gray4 {};func (_geccf *NRGBA64 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtNRGBA64 (x ,y ,_geccf .Width ,_geccf .Data ,_geccf .Alpha ,_geccf .Decode );
};func (_dged *Gray4 )Bounds ()_ee .Rectangle {return _ee .Rectangle {Max :_ee .Point {X :_dged .Width ,Y :_dged .Height }};};func (_cbdgb *NRGBA32 )Validate ()error {if len (_cbdgb .Data )!=3*_cbdgb .Width *_cbdgb .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func (_cabf *Gray4 )Set (x ,y int ,c _b .Color ){if x >=_cabf .Width ||y >=_cabf .Height {return ;};_efdg :=Gray4Model .Convert (c ).(_b .Gray );_cabf .setGray (x ,y ,_efdg );};func (_fffef *Monochrome )RasterOperation (dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _gffe (_fffef ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );
};func MonochromeModel (threshold uint8 )_b .Model {return monochromeModel (threshold )};type Gray4 struct{ImageBase };func (_acad *Monochrome )setGray (_fbge int ,_gfcd _b .Gray ,_edf int ){if _gfcd .Y ==0{_acad .clearBit (_edf ,_fbge );}else {_acad .setGrayBit (_edf ,_fbge );
};};func _fbd (_cbd ,_faa int )*Monochrome {return &Monochrome {ImageBase :NewImageBase (_cbd ,_faa ,1,1,nil ,nil ,nil ),ModelThreshold :0x0f};};func (_abf *ImageBase )GetAlpha ()[]byte {return _abf .Alpha };func _abcce (_afge uint )uint {var _fefd uint ;
for _afge !=0{_afge >>=1;_fefd ++;};return _fefd -1;};func ImgToBinary (i _ee .Image ,threshold uint8 )*_ee .Gray {switch _ddggd :=i .(type ){case *_ee .Gray :if _aeag (_ddggd ){return _ddggd ;};return _dbeg (_ddggd ,threshold );case *_ee .Gray16 :return _fbcbd (_ddggd ,threshold );
default:return _gffc (_ddggd ,threshold );};};type Gray interface{GrayAt (_ffeda ,_bbabg int )_b .Gray ;SetGray (_fed ,_fgg int ,_eac _b .Gray );};func (_dag *Gray16 )Histogram ()(_bfdbe [256]int ){for _eada :=0;_eada < _dag .Width ;_eada ++{for _cecg :=0;
_cecg < _dag .Height ;_cecg ++{_bfdbe [_dag .GrayAt (_eada ,_cecg ).Y ]++;};};return _bfdbe ;};var _ _ee .Image =&Gray4 {};func _bgefg (_baeee nrgba64 ,_bgb RGBA ,_bbeec _ee .Rectangle ){for _dbed :=0;_dbed < _bbeec .Max .X ;_dbed ++{for _acbd :=0;_acbd < _bbeec .Max .Y ;
_acbd ++{_bbeeg :=_baeee .NRGBA64At (_dbed ,_acbd );_bgb .SetRGBA (_dbed ,_acbd ,_cddc (_bbeeg ));};};};func _dcfg (_gad _ee .Image )(Image ,error ){if _fgd ,_dga :=_gad .(*CMYK32 );_dga {return _fgd .Copy (),nil ;};_def :=_gad .Bounds ();_ecaf ,_gdag :=NewImage (_def .Max .X ,_def .Max .Y ,8,4,nil ,nil ,nil );
if _gdag !=nil {return nil ,_gdag ;};switch _aed :=_gad .(type ){case CMYK :_dfd (_aed ,_ecaf .(CMYK ),_def );case Gray :_bcd (_aed ,_ecaf .(CMYK ),_def );case NRGBA :_bge (_aed ,_ecaf .(CMYK ),_def );case RGBA :_gacg (_aed ,_ecaf .(CMYK ),_def );default:_agbc (_gad ,_ecaf ,_def );
};return _ecaf ,nil ;};var _ NRGBA =&NRGBA32 {};type NRGBA64 struct{ImageBase };func (_bafd *Monochrome )At (x ,y int )_b .Color {_dcd ,_ :=_bafd .ColorAt (x ,y );return _dcd };func (_egba *Gray16 )Copy ()Image {return &Gray16 {ImageBase :_egba .copy ()}};
func RasterOperation (dest *Monochrome ,dx ,dy ,dw ,dh int ,op RasterOperator ,src *Monochrome ,sx ,sy int )error {return _gffe (dest ,dx ,dy ,dw ,dh ,op ,src ,sx ,sy );};func _cff (_fef _b .NYCbCrA )_b .NRGBA {_fgb :=int32 (_fef .Y )*0x10101;_bgfe :=int32 (_fef .Cb )-128;
_ebaa :=int32 (_fef .Cr )-128;_dfa :=_fgb +91881*_ebaa ;if uint32 (_dfa )&0xff000000==0{_dfa >>=8;}else {_dfa =^(_dfa >>31)&0xffff;};_agca :=_fgb -22554*_bgfe -46802*_ebaa ;if uint32 (_agca )&0xff000000==0{_agca >>=8;}else {_agca =^(_agca >>31)&0xffff;
};_gcf :=_fgb +116130*_bgfe ;if uint32 (_gcf )&0xff000000==0{_gcf >>=8;}else {_gcf =^(_gcf >>31)&0xffff;};return _b .NRGBA {R :uint8 (_dfa >>8),G :uint8 (_agca >>8),B :uint8 (_gcf >>8),A :_fef .A };};func (_caae *Gray8 )Validate ()error {if len (_caae .Data )!=_caae .Height *_caae .BytesPerLine {return ErrInvalidImage ;
};return nil ;};func IsGrayImgBlackAndWhite (i *_ee .Gray )bool {return _aeag (i )};func (_geab *ImageBase )newAlpha (){_efec :=BytesPerLine (_geab .Width ,_geab .BitsPerComponent ,1);_geab .Alpha =make ([]byte ,_geab .Height *_efec );};var _ _ee .Image =&Gray2 {};
func ColorAt (x ,y ,width ,bitsPerColor ,colorComponents ,bytesPerLine int ,data ,alpha []byte ,decode []float64 )(_b .Color ,error ){switch colorComponents {case 1:return ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine ,data ,decode );case 3:return ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor ,data ,alpha ,decode );
case 4:return ColorAtCMYK (x ,y ,width ,data ,decode );default:return nil ,_ge .Errorf ("\u0070\u0072\u006f\u0076\u0069\u0064\u0065\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0063o\u006c\u006f\u0072\u0020\u0063\u006f\u006dp\u006f\u006e\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0074h\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0064",colorComponents );
};};func _cgfgd (_ffbbf CMYK ,_eag NRGBA ,_bdfef _ee .Rectangle ){for _beed :=0;_beed < _bdfef .Max .X ;_beed ++{for _dgfg :=0;_dgfg < _bdfef .Max .Y ;_dgfg ++{_abgg :=_ffbbf .CMYKAt (_beed ,_dgfg );_eag .SetNRGBA (_beed ,_dgfg ,_gfcea (_abgg ));};};};
func (_cebe *Gray4 )At (x ,y int )_b .Color {_ecf ,_ :=_cebe .ColorAt (x ,y );return _ecf };func _gbbg (_ddda *_ee .NYCbCrA ,_ebce RGBA ,_deafd _ee .Rectangle ){for _feacc :=0;_feacc < _deafd .Max .X ;_feacc ++{for _cagc :=0;_cagc < _deafd .Max .Y ;_cagc ++{_aead :=_ddda .NYCbCrAAt (_feacc ,_cagc );
_ebce .SetRGBA (_feacc ,_cagc ,_cgf (_aead ));};};};func _cgfe (_ede Gray ,_eec nrgba64 ,_cbdff _ee .Rectangle ){for _dfab :=0;_dfab < _cbdff .Max .X ;_dfab ++{for _daa :=0;_daa < _cbdff .Max .Y ;_daa ++{_bffg :=_daba (_eec .NRGBA64At (_dfab ,_daa ));_ede .SetGray (_dfab ,_daa ,_bffg );
};};};func (_bfdda *Gray4 )SetGray (x ,y int ,g _b .Gray ){if x >=_bfdda .Width ||y >=_bfdda .Height {return ;};g =_efdf (g );_bfdda .setGray (x ,y ,g );};func (_gbgf *Gray2 )SetGray (x ,y int ,gray _b .Gray ){_fggf :=_dbda (gray );_baa :=y *_gbgf .BytesPerLine ;
_dfag :=_baa +(x >>2);if _dfag >=len (_gbgf .Data ){return ;};_bcga :=_fggf .Y >>6;_gbgf .Data [_dfag ]=(_gbgf .Data [_dfag ]&(^(0xc0>>uint (2*((x )&3)))))|(_bcga <<uint (6-2*(x &3)));};func (_dgea *Gray16 )GrayAt (x ,y int )_b .Gray {_geaf ,_ :=_dgea .ColorAt (x ,y );
return _b .Gray {Y :uint8 (_geaf .(_b .Gray16 ).Y >>8)};};var _ Image =&NRGBA16 {};var _ Image =&Gray4 {};func (_ceda *Gray4 )ColorModel ()_b .Model {return Gray4Model };func _aecg (_efba _ee .Image )(Image ,error ){if _egff ,_aebcb :=_efba .(*NRGBA64 );
_aebcb {return _egff .Copy (),nil ;};_ceace ,_bacba ,_fbf :=_feddd (_efba ,2);_geca ,_ffdc :=NewImage (_ceace .Max .X ,_ceace .Max .Y ,16,3,nil ,_fbf ,nil );if _ffdc !=nil {return nil ,_ffdc ;};_aebe (_efba ,_geca ,_ceace );if len (_fbf )!=0&&!_bacba {if _adec :=_bddgc (_fbf ,_geca );
_adec !=nil {return nil ,_adec ;};};return _geca ,nil ;};func (_cbda *RGBA32 )setRGBA (_fafc int ,_bfdfe _b .RGBA ){_gafab :=3*_fafc ;_cbda .Data [_gafab ]=_bfdfe .R ;_cbda .Data [_gafab +1]=_bfdfe .G ;_cbda .Data [_gafab +2]=_bfdfe .B ;if _fafc < len (_cbda .Alpha ){_cbda .Alpha [_fafc ]=_bfdfe .A ;
};};func (_bage *Gray8 )Set (x ,y int ,c _b .Color ){_gdceb :=y *_bage .BytesPerLine +x ;if _gdceb > len (_bage .Data )-1{return ;};_dafa :=_b .GrayModel .Convert (c );_bage .Data [_gdceb ]=_dafa .(_b .Gray ).Y ;};func _dee (_ffc _b .RGBA )_b .CMYK {_deae ,_bgfb ,_cbge ,_efgg :=_b .RGBToCMYK (_ffc .R ,_ffc .G ,_ffc .B );
return _b .CMYK {C :_deae ,M :_bgfb ,Y :_cbge ,K :_efgg };};func _dea (_fbe ,_ebc *Monochrome ,_bfdd []byte ,_bfa int )(_efg error ){var (_ebe ,_efd ,_eebf ,_bfb ,_dac ,_ddc ,_gded ,_degd int ;_dfg ,_bcc ,_gfd ,_gdaf uint32 ;_aac ,_eea byte ;_efc uint16 ;
);_bbfc :=make ([]byte ,4);_fffe :=make ([]byte ,4);for _eebf =0;_eebf < _fbe .Height -1;_eebf ,_bfb =_eebf +2,_bfb +1{_ebe =_eebf *_fbe .BytesPerLine ;_efd =_bfb *_ebc .BytesPerLine ;for _dac ,_ddc =0,0;_dac < _bfa ;_dac ,_ddc =_dac +4,_ddc +1{for _gded =0;
_gded < 4;_gded ++{_degd =_ebe +_dac +_gded ;if _degd <=len (_fbe .Data )-1&&_degd < _ebe +_fbe .BytesPerLine {_bbfc [_gded ]=_fbe .Data [_degd ];}else {_bbfc [_gded ]=0x00;};_degd =_ebe +_fbe .BytesPerLine +_dac +_gded ;if _degd <=len (_fbe .Data )-1&&_degd < _ebe +(2*_fbe .BytesPerLine ){_fffe [_gded ]=_fbe .Data [_degd ];
}else {_fffe [_gded ]=0x00;};};_dfg =_ba .BigEndian .Uint32 (_bbfc );_bcc =_ba .BigEndian .Uint32 (_fffe );_gfd =_dfg &_bcc ;_gfd |=_gfd <<1;_gdaf =_dfg |_bcc ;_gdaf &=_gdaf <<1;_bcc =_gfd &_gdaf ;_bcc &=0xaaaaaaaa;_dfg =_bcc |(_bcc <<7);_aac =byte (_dfg >>24);
_eea =byte ((_dfg >>8)&0xff);_degd =_efd +_ddc ;if _degd +1==len (_ebc .Data )-1||_degd +1>=_efd +_ebc .BytesPerLine {if _efg =_ebc .setByte (_degd ,_bfdd [_aac ]);_efg !=nil {return _ge .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_degd );};
}else {_efc =(uint16 (_bfdd [_aac ])<<8)|uint16 (_bfdd [_eea ]);if _efg =_ebc .setTwoBytes (_degd ,_efc );_efg !=nil {return _ge .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_degd );
};_ddc ++;};};};return nil ;};func (_aafc *Monochrome )setIndexedBit (_ffg int ){_aafc .Data [(_ffg >>3)]|=0x80>>uint (_ffg &7)};func AutoThresholdTriangle (histogram [256]int )uint8 {var _ffbbe ,_eaaee ,_ggge ,_adef int ;for _ggfcg :=0;_ggfcg < len (histogram );
_ggfcg ++{if histogram [_ggfcg ]> 0{_ffbbe =_ggfcg ;break ;};};if _ffbbe > 0{_ffbbe --;};for _degf :=255;_degf > 0;_degf --{if histogram [_degf ]> 0{_adef =_degf ;break ;};};if _adef < 255{_adef ++;};for _bceb :=0;_bceb < 256;_bceb ++{if histogram [_bceb ]> _eaaee {_ggge =_bceb ;
_eaaee =histogram [_bceb ];};};var _bdfa bool ;if (_ggge -_ffbbe )< (_adef -_ggge ){_bdfa =true ;var _aebcg int ;_cgee :=255;for _aebcg < _cgee {_bggff :=histogram [_aebcg ];histogram [_aebcg ]=histogram [_cgee ];histogram [_cgee ]=_bggff ;_aebcg ++;_cgee --;
};_ffbbe =255-_adef ;_ggge =255-_ggge ;};if _ffbbe ==_ggge {return uint8 (_ffbbe );};_febc :=float64 (histogram [_ggge ]);_fagc :=float64 (_ffbbe -_ggge );_egfba :=_a .Sqrt (_febc *_febc +_fagc *_fagc );_febc /=_egfba ;_fagc /=_egfba ;_egfba =_febc *float64 (_ffbbe )+_fagc *float64 (histogram [_ffbbe ]);
_agaa :=_ffbbe ;var _dfae float64 ;for _ggcf :=_ffbbe +1;_ggcf <=_ggge ;_ggcf ++{_ceaa :=_febc *float64 (_ggcf )+_fagc *float64 (histogram [_ggcf ])-_egfba ;if _ceaa > _dfae {_agaa =_ggcf ;_dfae =_ceaa ;};};_agaa --;if _bdfa {var _bcfa int ;_gabb :=255;
for _bcfa < _gabb {_gbfa :=histogram [_bcfa ];histogram [_bcfa ]=histogram [_gabb ];histogram [_gabb ]=_gbfa ;_bcfa ++;_gabb --;};return uint8 (255-_agaa );};return uint8 (_agaa );};func _fab (_cbe _b .Gray )_b .CMYK {return _b .CMYK {K :0xff-_cbe .Y }};
func (_fffa *ImageBase )setFourBytes (_ffgc int ,_bccg uint32 )error {if _ffgc +3> len (_fffa .Data )-1{return _ge .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006fu\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065",_ffgc );
};_fffa .Data [_ffgc ]=byte ((_bccg &0xff000000)>>24);_fffa .Data [_ffgc +1]=byte ((_bccg &0xff0000)>>16);_fffa .Data [_ffgc +2]=byte ((_bccg &0xff00)>>8);_fffa .Data [_ffgc +3]=byte (_bccg &0xff);return nil ;};func _geg (_gfc ,_efa int ,_bcf []byte )*Monochrome {_bd :=_fbd (_gfc ,_efa );
_bd .Data =_bcf ;return _bd ;};func (_fabe *Gray8 )Bounds ()_ee .Rectangle {return _ee .Rectangle {Max :_ee .Point {X :_fabe .Width ,Y :_fabe .Height }};};func (_bac *Gray2 )Bounds ()_ee .Rectangle {return _ee .Rectangle {Max :_ee .Point {X :_bac .Width ,Y :_bac .Height }};
};func _edaae (_cdfad *Monochrome ,_egda ,_cdfge int ,_gfae ,_cfff int ,_cecd RasterOperator ,_edbe *Monochrome ,_dgae ,_ggd int )error {var _cdb ,_eefdf ,_cbc ,_fcba int ;if _egda < 0{_dgae -=_egda ;_gfae +=_egda ;_egda =0;};if _dgae < 0{_egda -=_dgae ;
_gfae +=_dgae ;_dgae =0;};_cdb =_egda +_gfae -_cdfad .Width ;if _cdb > 0{_gfae -=_cdb ;};_eefdf =_dgae +_gfae -_edbe .Width ;if _eefdf > 0{_gfae -=_eefdf ;};if _cdfge < 0{_ggd -=_cdfge ;_cfff +=_cdfge ;_cdfge =0;};if _ggd < 0{_cdfge -=_ggd ;_cfff +=_ggd ;
_ggd =0;};_cbc =_cdfge +_cfff -_cdfad .Height ;if _cbc > 0{_cfff -=_cbc ;};_fcba =_ggd +_cfff -_edbe .Height ;if _fcba > 0{_cfff -=_fcba ;};if _gfae <=0||_cfff <=0{return nil ;};var _dedg error ;switch {case _egda &7==0&&_dgae &7==0:_dedg =_gacf (_cdfad ,_egda ,_cdfge ,_gfae ,_cfff ,_cecd ,_edbe ,_dgae ,_ggd );
case _egda &7==_dgae &7:_dedg =_afag (_cdfad ,_egda ,_cdfge ,_gfae ,_cfff ,_cecd ,_edbe ,_dgae ,_ggd );default:_dedg =_dfed (_cdfad ,_egda ,_cdfge ,_gfae ,_cfff ,_cecd ,_edbe ,_dgae ,_ggd );};if _dedg !=nil {return _dedg ;};return nil ;};func (_ebeg *RGBA32 )RGBAAt (x ,y int )_b .RGBA {_bdc ,_ :=ColorAtRGBA32 (x ,y ,_ebeg .Width ,_ebeg .Data ,_ebeg .Alpha ,_ebeg .Decode );
return _bdc ;};func FromGoImage (i _ee .Image )(Image ,error ){switch _gcda :=i .(type ){case Image :return _gcda .Copy (),nil ;case Gray :return GrayConverter .Convert (i );case *_ee .Gray16 :return Gray16Converter .Convert (i );case CMYK :return CMYKConverter .Convert (i );
case *_ee .NRGBA64 :return NRGBA64Converter .Convert (i );default:return NRGBAConverter .Convert (i );};};func (_dbaf *NRGBA16 )Set (x ,y int ,c _b .Color ){_aba :=y *_dbaf .BytesPerLine +x *3/2;if _aba +1>=len (_dbaf .Data ){return ;};_degg :=NRGBA16Model .Convert (c ).(_b .NRGBA );
_dbaf .setNRGBA (x ,y ,_aba ,_degg );};func ColorAtNRGBA64 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_b .NRGBA64 ,error ){_bebfa :=(y *width +x )*2;_eege :=_bebfa *3;if _eege +5>=len (data ){return _b .NRGBA64 {},_ge .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};const _dacag =0xffff;_fdfagd :=uint16 (_dacag );if alpha !=nil &&len (alpha )> _bebfa +1{_fdfagd =uint16 (alpha [_bebfa ])<<8|uint16 (alpha [_bebfa +1]);};_fdec :=uint16 (data [_eege ])<<8|uint16 (data [_eege +1]);_cbeg :=uint16 (data [_eege +2])<<8|uint16 (data [_eege +3]);
_ggc :=uint16 (data [_eege +4])<<8|uint16 (data [_eege +5]);if len (decode )==6{_fdec =uint16 (uint64 (LinearInterpolate (float64 (_fdec ),0,65535,decode [0],decode [1]))&_dacag );_cbeg =uint16 (uint64 (LinearInterpolate (float64 (_cbeg ),0,65535,decode [2],decode [3]))&_dacag );
_ggc =uint16 (uint64 (LinearInterpolate (float64 (_ggc ),0,65535,decode [4],decode [5]))&_dacag );};return _b .NRGBA64 {R :_fdec ,G :_cbeg ,B :_ggc ,A :_fdfagd },nil ;};func (_bbd *Monochrome )getBitAt (_gbde ,_gbaa int )bool {_cccf :=_gbaa *_bbd .BytesPerLine +(_gbde >>3);
_fcc :=_gbde &0x07;_daaf :=uint (7-_fcc );if _cccf > len (_bbd .Data )-1{return false ;};if (_bbd .Data [_cccf ]>>_daaf )&0x01>=1{return true ;};return false ;};func (_ffab *Monochrome )AddPadding ()(_adbd error ){if _acg :=((_ffab .Width *_ffab .Height )+7)>>3;
len (_ffab .Data )< _acg {return _ge .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0064a\u0074\u0061\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u003a\u0020\u0027\u0025\u0064\u0027\u002e\u0020\u0054\u0068\u0065\u0020\u0064\u0061t\u0061\u0020s\u0068\u006fu\u006c\u0064\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 l\u0065\u0061\u0073\u0074\u003a\u0020\u0027\u0025\u0064'\u0020\u0062\u0079\u0074\u0065\u0073",len (_ffab .Data ),_acg );
};_fbc :=_ffab .Width %8;if _fbc ==0{return nil ;};_ddeg :=_ffab .Width /8;_cbfa :=_ff .NewReader (_ffab .Data );_gaga :=make ([]byte ,_ffab .Height *_ffab .BytesPerLine );_aec :=_ff .NewWriterMSB (_gaga );_ced :=make ([]byte ,_ddeg );var (_cgfg int ;_gdcd uint64 ;
);for _cgfg =0;_cgfg < _ffab .Height ;_cgfg ++{if _ ,_adbd =_cbfa .Read (_ced );_adbd !=nil {return _adbd ;};if _ ,_adbd =_aec .Write (_ced );_adbd !=nil {return _adbd ;};if _gdcd ,_adbd =_cbfa .ReadBits (byte (_fbc ));_adbd !=nil {return _adbd ;};if _adbd =_aec .WriteByte (byte (_gdcd )<<uint (8-_fbc ));
_adbd !=nil {return _adbd ;};};_ffab .Data =_aec .Data ();return nil ;};func ImgToGray (i _ee .Image )*_ee .Gray {if _dbaga ,_eegdf :=i .(*_ee .Gray );_eegdf {return _dbaga ;};_gagbd :=i .Bounds ();_gabc :=_ee .NewGray (_gagbd );for _fffea :=0;_fffea < _gagbd .Max .X ;
_fffea ++{for _beeb :=0;_beeb < _gagbd .Max .Y ;_beeb ++{_aafa :=i .At (_fffea ,_beeb );_gabc .Set (_fffea ,_beeb ,_aafa );};};return _gabc ;};var _ _ee .Image =&Gray8 {};func _deebf (_ebad *Monochrome ,_bfg ,_eggc ,_daee ,_afed int ,_gcb RasterOperator ){if _bfg < 0{_daee +=_bfg ;
_bfg =0;};_gbfd :=_bfg +_daee -_ebad .Width ;if _gbfd > 0{_daee -=_gbfd ;};if _eggc < 0{_afed +=_eggc ;_eggc =0;};_cfga :=_eggc +_afed -_ebad .Height ;if _cfga > 0{_afed -=_cfga ;};if _daee <=0||_afed <=0{return ;};if (_bfg &7)==0{_bfcg (_ebad ,_bfg ,_eggc ,_daee ,_afed ,_gcb );
}else {_gdcg (_ebad ,_bfg ,_eggc ,_daee ,_afed ,_gcb );};};func _agc (_gbae *Monochrome ,_ddg ,_gc int )(*Monochrome ,error ){if _gbae ==nil {return nil ,_g .New ("\u0073o\u0075r\u0063\u0065\u0020\u006e\u006ft\u0020\u0064e\u0066\u0069\u006e\u0065\u0064");
};if _ddg <=0||_gc <=0{return nil ,_g .New ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0073\u0063\u0061l\u0065\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020<\u003d\u0020\u0030");};if _ddg ==_gc {if _ddg ==1{return _gbae .copy (),nil ;};
if _ddg ==2||_ddg ==4||_ddg ==8{_eeb ,_gee :=_gf (_gbae ,_ddg );if _gee !=nil {return nil ,_gee ;};return _eeb ,nil ;};};_fg :=_ddg *_gbae .Width ;_dce :=_gc *_gbae .Height ;_bbeg :=_fbd (_fg ,_dce );_gde :=_bbeg .BytesPerLine ;var (_cbf ,_cab ,_afd ,_bba ,_fgf int ;
_gfa byte ;_agd error ;);for _cab =0;_cab < _gbae .Height ;_cab ++{_cbf =_gc *_cab *_gde ;for _afd =0;_afd < _gbae .Width ;_afd ++{if _bg :=_gbae .getBitAt (_afd ,_cab );_bg {_fgf =_ddg *_afd ;for _bba =0;_bba < _ddg ;_bba ++{_bbeg .setIndexedBit (_cbf *8+_fgf +_bba );
};};};for _bba =1;_bba < _gc ;_bba ++{_dde :=_cbf +_bba *_gde ;for _de :=0;_de < _gde ;_de ++{if _gfa ,_agd =_bbeg .getByte (_cbf +_de );_agd !=nil {return nil ,_agd ;};if _agd =_bbeg .setByte (_dde +_de ,_gfa );_agd !=nil {return nil ,_agd ;};};};};return _bbeg ,nil ;
};func _cdgb (_ecab int ,_bcba int )int {if _ecab < _bcba {return _ecab ;};return _bcba ;};func (_bgeg *NRGBA64 )Bounds ()_ee .Rectangle {return _ee .Rectangle {Max :_ee .Point {X :_bgeg .Width ,Y :_bgeg .Height }};};func (_cdfe *RGBA32 )ColorModel ()_b .Model {return _b .NRGBAModel };
func _dfd (_edaa ,_cad CMYK ,_dec _ee .Rectangle ){for _gcd :=0;_gcd < _dec .Max .X ;_gcd ++{for _gfaf :=0;_gfaf < _dec .Max .Y ;_gfaf ++{_cad .SetCMYK (_gcd ,_gfaf ,_edaa .CMYKAt (_gcd ,_gfaf ));};};};func (_efgca *NRGBA16 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtNRGBA16 (x ,y ,_efgca .Width ,_efgca .BytesPerLine ,_efgca .Data ,_efgca .Alpha ,_efgca .Decode );
};func (_adcg *CMYK32 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtCMYK (x ,y ,_adcg .Width ,_adcg .Data ,_adcg .Decode );};func _ef ()(_afa [256]uint64 ){for _fdf :=0;_fdf < 256;_fdf ++{if _fdf &0x01!=0{_afa [_fdf ]|=0xff;};if _fdf &0x02!=0{_afa [_fdf ]|=0xff00;
};if _fdf &0x04!=0{_afa [_fdf ]|=0xff0000;};if _fdf &0x08!=0{_afa [_fdf ]|=0xff000000;};if _fdf &0x10!=0{_afa [_fdf ]|=0xff00000000;};if _fdf &0x20!=0{_afa [_fdf ]|=0xff0000000000;};if _fdf &0x40!=0{_afa [_fdf ]|=0xff000000000000;};if _fdf &0x80!=0{_afa [_fdf ]|=0xff00000000000000;
};};return _afa ;};func _cec (_cge _b .RGBA )_b .Gray {_agab :=(19595*uint32 (_cge .R )+38470*uint32 (_cge .G )+7471*uint32 (_cge .B )+1<<7)>>16;return _b .Gray {Y :uint8 (_agab )};};func (_gggc *Monochrome )ReduceBinary (factor float64 )(*Monochrome ,error ){_gce :=_abcce (uint (factor ));
if !IsPowerOf2 (uint (factor )){_gce ++;};_bdg :=make ([]int ,_gce );for _cgcg :=range _bdg {_bdg [_cgcg ]=4;};_fggd ,_bafb :=_ddga (_gggc ,_bdg ...);if _bafb !=nil {return nil ,_bafb ;};return _fggd ,nil ;};func (_gfb *ImageBase )setByte (_efeb int ,_fgef byte )error {if _efeb > len (_gfb .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");
};_gfb .Data [_efeb ]=_fgef ;return nil ;};type CMYK32 struct{ImageBase };func (_fdcc *NRGBA32 )setRGBA (_ggef int ,_adf _b .NRGBA ){_gafc :=3*_ggef ;_fdcc .Data [_gafc ]=_adf .R ;_fdcc .Data [_gafc +1]=_adf .G ;_fdcc .Data [_gafc +2]=_adf .B ;if _ggef < len (_fdcc .Alpha ){_fdcc .Alpha [_ggef ]=_adf .A ;
};};func (_ageg *Monochrome )IsUnpadded ()bool {return (_ageg .Width *_ageg .Height )==len (_ageg .Data )};type ColorConverter interface{Convert (_bfab _ee .Image )(Image ,error );};func (_gaa *Monochrome )GrayAt (x ,y int )_b .Gray {_ccc ,_ :=ColorAtGray1BPC (x ,y ,_gaa .BytesPerLine ,_gaa .Data ,_gaa .Decode );
return _ccc ;};func _aaba (_affd _ee .Image ,_fbed Image ,_bcb _ee .Rectangle ){switch _bcdag :=_affd .(type ){case Gray :_dfdd (_bcdag ,_fbed .(Gray ),_bcb );case NRGBA :_gegd (_bcdag ,_fbed .(Gray ),_bcb );case CMYK :_eee (_bcdag ,_fbed .(Gray ),_bcb );
case RGBA :_bbec (_bcdag ,_fbed .(Gray ),_bcb );default:_agbc (_affd ,_fbed ,_bcb );};};func (_fffc *NRGBA16 )At (x ,y int )_b .Color {_fbea ,_ :=_fffc .ColorAt (x ,y );return _fbea };func (_gagaa *Gray8 )Base ()*ImageBase {return &_gagaa .ImageBase };
func _fge ()(_dda [256]uint32 ){for _aef :=0;_aef < 256;_aef ++{if _aef &0x01!=0{_dda [_aef ]|=0xf;};if _aef &0x02!=0{_dda [_aef ]|=0xf0;};if _aef &0x04!=0{_dda [_aef ]|=0xf00;};if _aef &0x08!=0{_dda [_aef ]|=0xf000;};if _aef &0x10!=0{_dda [_aef ]|=0xf0000;
};if _aef &0x20!=0{_dda [_aef ]|=0xf00000;};if _aef &0x40!=0{_dda [_aef ]|=0xf000000;};if _aef &0x80!=0{_dda [_aef ]|=0xf0000000;};};return _dda ;};func _dfdd (_eaaeb ,_cfgg Gray ,_gecd _ee .Rectangle ){for _fbde :=0;_fbde < _gecd .Max .X ;_fbde ++{for _feac :=0;
_feac < _gecd .Max .Y ;_feac ++{_cfgg .SetGray (_fbde ,_feac ,_eaaeb .GrayAt (_fbde ,_feac ));};};};func (_becb *NRGBA32 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtNRGBA32 (x ,y ,_becb .Width ,_becb .Data ,_becb .Alpha ,_becb .Decode );};func (_edcg *Gray16 )Validate ()error {if len (_edcg .Data )!=_edcg .Height *_edcg .BytesPerLine {return ErrInvalidImage ;
};return nil ;};var (MonochromeConverter =ConverterFunc (_gddg );Gray2Converter =ConverterFunc (_aeg );Gray4Converter =ConverterFunc (_bed );GrayConverter =ConverterFunc (_adbb );Gray16Converter =ConverterFunc (_ecb );NRGBA16Converter =ConverterFunc (_fccg );
NRGBAConverter =ConverterFunc (_bdaf );NRGBA64Converter =ConverterFunc (_aecg );RGBAConverter =ConverterFunc (_becd );CMYKConverter =ConverterFunc (_dcfg ););type CMYK interface{CMYKAt (_eefd ,_gef int )_b .CMYK ;SetCMYK (_gaff ,_baf int ,_fbg _b .CMYK );
};func _gdcg (_gbaea *Monochrome ,_gdcge ,_geeg int ,_aadef ,_cbaf int ,_fdda RasterOperator ){var (_gaad bool ;_bgdg bool ;_ggda int ;_gagg int ;_efbb int ;_dcgge int ;_afcf bool ;_cdag byte ;);_bdba :=8-(_gdcge &7);_abef :=_eafb [_bdba ];_agdc :=_gbaea .BytesPerLine *_geeg +(_gdcge >>3);
if _aadef < _bdba {_gaad =true ;_abef &=_gedd [8-_bdba +_aadef ];};if !_gaad {_ggda =(_aadef -_bdba )>>3;if _ggda !=0{_bgdg =true ;_gagg =_agdc +1;};};_efbb =(_gdcge +_aadef )&7;if !(_gaad ||_efbb ==0){_afcf =true ;_cdag =_gedd [_efbb ];_dcgge =_agdc +1+_ggda ;
};var _affed ,_fcd int ;switch _fdda {case PixClr :for _affed =0;_affed < _cbaf ;_affed ++{_gbaea .Data [_agdc ]=_dabg (_gbaea .Data [_agdc ],0x0,_abef );_agdc +=_gbaea .BytesPerLine ;};if _bgdg {for _affed =0;_affed < _cbaf ;_affed ++{for _fcd =0;_fcd < _ggda ;
_fcd ++{_gbaea .Data [_gagg +_fcd ]=0x0;};_gagg +=_gbaea .BytesPerLine ;};};if _afcf {for _affed =0;_affed < _cbaf ;_affed ++{_gbaea .Data [_dcgge ]=_dabg (_gbaea .Data [_dcgge ],0x0,_cdag );_dcgge +=_gbaea .BytesPerLine ;};};case PixSet :for _affed =0;
_affed < _cbaf ;_affed ++{_gbaea .Data [_agdc ]=_dabg (_gbaea .Data [_agdc ],0xff,_abef );_agdc +=_gbaea .BytesPerLine ;};if _bgdg {for _affed =0;_affed < _cbaf ;_affed ++{for _fcd =0;_fcd < _ggda ;_fcd ++{_gbaea .Data [_gagg +_fcd ]=0xff;};_gagg +=_gbaea .BytesPerLine ;
};};if _afcf {for _affed =0;_affed < _cbaf ;_affed ++{_gbaea .Data [_dcgge ]=_dabg (_gbaea .Data [_dcgge ],0xff,_cdag );_dcgge +=_gbaea .BytesPerLine ;};};case PixNotDst :for _affed =0;_affed < _cbaf ;_affed ++{_gbaea .Data [_agdc ]=_dabg (_gbaea .Data [_agdc ],^_gbaea .Data [_agdc ],_abef );
_agdc +=_gbaea .BytesPerLine ;};if _bgdg {for _affed =0;_affed < _cbaf ;_affed ++{for _fcd =0;_fcd < _ggda ;_fcd ++{_gbaea .Data [_gagg +_fcd ]=^(_gbaea .Data [_gagg +_fcd ]);};_gagg +=_gbaea .BytesPerLine ;};};if _afcf {for _affed =0;_affed < _cbaf ;_affed ++{_gbaea .Data [_dcgge ]=_dabg (_gbaea .Data [_dcgge ],^_gbaea .Data [_dcgge ],_cdag );
_dcgge +=_gbaea .BytesPerLine ;};};};};func (_gebd *Monochrome )ScaleLow (width ,height int )(*Monochrome ,error ){if width < 0||height < 0{return nil ,_g .New ("\u0070\u0072\u006f\u0076\u0069\u0064e\u0064\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077\u0069\u0064t\u0068\u0020\u0061\u006e\u0064\u0020\u0068e\u0069\u0067\u0068\u0074");
};_dfe :=_fbd (width ,height );_fedd :=make ([]int ,height );_ccbb :=make ([]int ,width );_fafg :=float64 (_gebd .Width )/float64 (width );_fad :=float64 (_gebd .Height )/float64 (height );for _cdfa :=0;_cdfa < height ;_cdfa ++{_fedd [_cdfa ]=int (_a .Min (_fad *float64 (_cdfa )+0.5,float64 (_gebd .Height -1)));
};for _gafg :=0;_gafg < width ;_gafg ++{_ccbb [_gafg ]=int (_a .Min (_fafg *float64 (_gafg )+0.5,float64 (_gebd .Width -1)));};_cacc :=-1;_abd :=byte (0);for _bfdb :=0;_bfdb < height ;_bfdb ++{_fdgd :=_fedd [_bfdb ]*_gebd .BytesPerLine ;_fcac :=_bfdb *_dfe .BytesPerLine ;
for _agac :=0;_agac < width ;_agac ++{_ccde :=_ccbb [_agac ];if _ccde !=_cacc {_abd =_gebd .getBit (_fdgd ,_ccde );if _abd !=0{_dfe .setBit (_fcac ,_agac );};_cacc =_ccde ;}else {if _abd !=0{_dfe .setBit (_fcac ,_agac );};};};};return _dfe ,nil ;};func _affc (_ceab RGBA ,_cddbf NRGBA ,_eegg _ee .Rectangle ){for _cbcb :=0;
_cbcb < _eegg .Max .X ;_cbcb ++{for _eeabb :=0;_eeabb < _eegg .Max .Y ;_eeabb ++{_edgee :=_ceab .RGBAAt (_cbcb ,_eeabb );_cddbf .SetNRGBA (_cbcb ,_eeabb ,_abcc (_edgee ));};};};type Monochrome struct{ImageBase ;ModelThreshold uint8 ;};func (_ddag *NRGBA32 )Set (x ,y int ,c _b .Color ){_aea :=y *_ddag .Width +x ;
_gcc :=3*_aea ;if _gcc +2>=len (_ddag .Data ){return ;};_gbfb :=_b .NRGBAModel .Convert (c ).(_b .NRGBA );_ddag .setRGBA (_aea ,_gbfb );};func (_afce *NRGBA16 )SetNRGBA (x ,y int ,c _b .NRGBA ){_ccfe :=y *_afce .BytesPerLine +x *3/2;if _ccfe +1>=len (_afce .Data ){return ;
};c =_cfdc (c );_afce .setNRGBA (x ,y ,_ccfe ,c );};func _bdaf (_daag _ee .Image )(Image ,error ){if _ageb ,_gffeb :=_daag .(*NRGBA32 );_gffeb {return _ageb .Copy (),nil ;};_gdadd ,_acfgf ,_ggdd :=_feddd (_daag ,1);_efea ,_bbfb :=NewImage (_gdadd .Max .X ,_gdadd .Max .Y ,8,3,nil ,_ggdd ,nil );
if _bbfb !=nil {return nil ,_bbfb ;};_acdc (_daag ,_efea ,_gdadd );if len (_ggdd )!=0&&!_acfgf {if _cbedb :=_bddgc (_ggdd ,_efea );_cbedb !=nil {return nil ,_cbedb ;};};return _efea ,nil ;};func _edab (_egbc ,_cac *Monochrome ,_daf []byte ,_cbdg int )(_aaa error ){var (_ceea ,_ddac ,_ace ,_cfb ,_gdg ,_caba ,_dceb ,_fdfa int ;
_dae ,_gff ,_cgg ,_ggf uint32 ;_gbc ,_dgbc byte ;_agb uint16 ;);_deg :=make ([]byte ,4);_fff :=make ([]byte ,4);for _ace =0;_ace < _egbc .Height -1;_ace ,_cfb =_ace +2,_cfb +1{_ceea =_ace *_egbc .BytesPerLine ;_ddac =_cfb *_cac .BytesPerLine ;for _gdg ,_caba =0,0;
_gdg < _cbdg ;_gdg ,_caba =_gdg +4,_caba +1{for _dceb =0;_dceb < 4;_dceb ++{_fdfa =_ceea +_gdg +_dceb ;if _fdfa <=len (_egbc .Data )-1&&_fdfa < _ceea +_egbc .BytesPerLine {_deg [_dceb ]=_egbc .Data [_fdfa ];}else {_deg [_dceb ]=0x00;};_fdfa =_ceea +_egbc .BytesPerLine +_gdg +_dceb ;
if _fdfa <=len (_egbc .Data )-1&&_fdfa < _ceea +(2*_egbc .BytesPerLine ){_fff [_dceb ]=_egbc .Data [_fdfa ];}else {_fff [_dceb ]=0x00;};};_dae =_ba .BigEndian .Uint32 (_deg );_gff =_ba .BigEndian .Uint32 (_fff );_cgg =_dae &_gff ;_cgg |=_cgg <<1;_ggf =_dae |_gff ;
_ggf &=_ggf <<1;_gff =_cgg |_ggf ;_gff &=0xaaaaaaaa;_dae =_gff |(_gff <<7);_gbc =byte (_dae >>24);_dgbc =byte ((_dae >>8)&0xff);_fdfa =_ddac +_caba ;if _fdfa +1==len (_cac .Data )-1||_fdfa +1>=_ddac +_cac .BytesPerLine {if _aaa =_cac .setByte (_fdfa ,_daf [_gbc ]);
_aaa !=nil {return _ge .Errorf ("\u0069n\u0064\u0065\u0078\u003a\u0020\u0025d",_fdfa );};}else {_agb =(uint16 (_daf [_gbc ])<<8)|uint16 (_daf [_dgbc ]);if _aaa =_cac .setTwoBytes (_fdfa ,_agb );_aaa !=nil {return _ge .Errorf ("s\u0065\u0074\u0074\u0069\u006e\u0067 \u0074\u0077\u006f\u0020\u0062\u0079t\u0065\u0073\u0020\u0066\u0061\u0069\u006ce\u0064\u002c\u0020\u0069\u006e\u0064\u0065\u0078\u003a\u0020%\u0064",_fdfa );
};_caba ++;};};};return nil ;};func IsPowerOf2 (n uint )bool {return n > 0&&(n &(n -1))==0};func _ab (_c *Monochrome ,_fa int ,_af []uint )(*Monochrome ,error ){_cg :=_fa *_c .Width ;_ffb :=_fa *_c .Height ;_gb :=_fbd (_cg ,_ffb );for _abg ,_cb :=range _af {var _geb error ;
switch _cb {case 2:_geb =_beb (_gb ,_c );case 4:_geb =_ada (_gb ,_c );case 8:_geb =_ea (_gb ,_c );};if _geb !=nil {return nil ,_geb ;};if _abg !=len (_af )-1{_c =_gb .copy ();};};return _gb ,nil ;};func (_deba *Monochrome )ExpandBinary (factor int )(*Monochrome ,error ){if !IsPowerOf2 (uint (factor )){return nil ,_ge .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0065\u0078\u0070\u0061\u006e\u0064\u0020b\u0069n\u0061\u0072\u0079\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u003a\u0020\u0025\u0064",factor );
};return _gf (_deba ,factor );};type shift int ;func (_ffad *CMYK32 )At (x ,y int )_b .Color {_ebae ,_ :=_ffad .ColorAt (x ,y );return _ebae };func (_fbb *Monochrome )ColorModel ()_b .Model {return MonochromeModel (_fbb .ModelThreshold )};func _fdfd (_feff _ee .Image ,_fae Image ,_geccd _ee .Rectangle ){if _affbd ,_ccaa :=_feff .(SMasker );
_ccaa &&_affbd .HasAlpha (){_fae .(SMasker ).MakeAlpha ();};switch _beggg :=_feff .(type ){case Gray :_eadd (_beggg ,_fae .(RGBA ),_geccd );case NRGBA :_ggdb (_beggg ,_fae .(RGBA ),_geccd );case *_ee .NYCbCrA :_gbbg (_beggg ,_fae .(RGBA ),_geccd );case CMYK :_eebda (_beggg ,_fae .(RGBA ),_geccd );
case RGBA :_fdaf (_beggg ,_fae .(RGBA ),_geccd );case nrgba64 :_bgefg (_beggg ,_fae .(RGBA ),_geccd );default:_agbc (_feff ,_fae ,_geccd );};};func _feddd (_fddae _ee .Image ,_ffage int )(_ee .Rectangle ,bool ,[]byte ){_acdf :=_fddae .Bounds ();var (_afeb bool ;
_bageg []byte ;);switch _dgfc :=_fddae .(type ){case SMasker :_afeb =_dgfc .HasAlpha ();case NRGBA ,RGBA ,*_ee .RGBA64 ,nrgba64 ,*_ee .NYCbCrA :_bageg =make ([]byte ,_acdf .Max .X *_acdf .Max .Y *_ffage );case *_ee .Paletted :var _gdcdg bool ;for _ ,_bcbe :=range _dgfc .Palette {_abcb ,_fffbb ,_begg ,_dgeae :=_bcbe .RGBA ();
if _abcb ==0&&_fffbb ==0&&_begg ==0&&_dgeae !=0{_gdcdg =true ;break ;};};if _gdcdg {_bageg =make ([]byte ,_acdf .Max .X *_acdf .Max .Y *_ffage );};};return _acdf ,_afeb ,_bageg ;};func LinearInterpolate (x ,xmin ,xmax ,ymin ,ymax float64 )float64 {if _a .Abs (xmax -xmin )< 0.000001{return ymin ;
};_ffbd :=ymin +(x -xmin )*(ymax -ymin )/(xmax -xmin );return _ffbd ;};func (_agec *Gray4 )Histogram ()(_gddce [256]int ){for _efge :=0;_efge < _agec .Width ;_efge ++{for _bcagd :=0;_bcagd < _agec .Height ;_bcagd ++{_gddce [_agec .GrayAt (_efge ,_bcagd ).Y ]++;
};};return _gddce ;};var _ Gray =&Gray16 {};func _gdgg (_cfcf ,_baag uint8 )uint8 {if _cfcf < _baag {return 255;};return 0;};func (_caff *Gray8 )GrayAt (x ,y int )_b .Gray {_gebc ,_ :=ColorAtGray8BPC (x ,y ,_caff .BytesPerLine ,_caff .Data ,_caff .Decode );
return _gebc ;};func _ecb (_edbd _ee .Image )(Image ,error ){if _dbf ,_afab :=_edbd .(*Gray16 );_afab {return _dbf .Copy (),nil ;};_gfcc :=_edbd .Bounds ();_gafa ,_fbgf :=NewImage (_gfcc .Max .X ,_gfcc .Max .Y ,16,1,nil ,nil ,nil );if _fbgf !=nil {return nil ,_fbgf ;
};_aaba (_edbd ,_gafa ,_gfcc );return _gafa ,nil ;};func (_dfagd *Gray2 )Histogram ()(_cgec [256]int ){for _cef :=0;_cef < _dfagd .Width ;_cef ++{for _aagd :=0;_aagd < _dfagd .Height ;_aagd ++{_cgec [_dfagd .GrayAt (_cef ,_aagd ).Y ]++;};};return _cgec ;
};func _aebe (_decc _ee .Image ,_gfaea Image ,_fgag _ee .Rectangle ){if _aaee ,_begb :=_decc .(SMasker );_begb &&_aaee .HasAlpha (){_gfaea .(SMasker ).MakeAlpha ();};_agbc (_decc ,_gfaea ,_fgag );};func (_afcb *Gray2 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray2BPC (x ,y ,_afcb .BytesPerLine ,_afcb .Data ,_afcb .Decode );
};var (_ec =_gbe ();_edge =_fge ();_eaa =_ef (););func (_egab *NRGBA64 )NRGBA64At (x ,y int )_b .NRGBA64 {_bddd ,_ :=ColorAtNRGBA64 (x ,y ,_egab .Width ,_egab .Data ,_egab .Alpha ,_egab .Decode );return _bddd ;};func (_dafe *NRGBA32 )SetNRGBA (x ,y int ,c _b .NRGBA ){_cfadb :=y *_dafe .Width +x ;
_gfcg :=3*_cfadb ;if _gfcg +2>=len (_dafe .Data ){return ;};_dafe .setRGBA (_cfadb ,c );};func (_dgfbf *NRGBA16 )Copy ()Image {return &NRGBA16 {ImageBase :_dgfbf .copy ()}};func _adcag (_ebade uint8 )bool {if _ebade ==0||_ebade ==255{return true ;};return false ;
};func (_fggg *Monochrome )copy ()*Monochrome {_gdf :=_fbd (_fggg .Width ,_fggg .Height );_gdf .ModelThreshold =_fggg .ModelThreshold ;_gdf .Data =make ([]byte ,len (_fggg .Data ));copy (_gdf .Data ,_fggg .Data );if len (_fggg .Decode )!=0{_gdf .Decode =make ([]float64 ,len (_fggg .Decode ));
copy (_gdf .Decode ,_fggg .Decode );};if len (_fggg .Alpha )!=0{_gdf .Alpha =make ([]byte ,len (_fggg .Alpha ));copy (_gdf .Alpha ,_fggg .Alpha );};return _gdf ;};func (_accb *NRGBA64 )Copy ()Image {return &NRGBA64 {ImageBase :_accb .copy ()}};func _fdad (_fbdf _b .Gray )_b .NRGBA {return _b .NRGBA {R :_fbdf .Y ,G :_fbdf .Y ,B :_fbdf .Y ,A :0xff}};
type SMasker interface{HasAlpha ()bool ;GetAlpha ()[]byte ;MakeAlpha ();};func (_ffbb *NRGBA32 )ColorModel ()_b .Model {return _b .NRGBAModel };type RGBA32 struct{ImageBase };var _ _ee .Image =&RGBA32 {};func (_ecg *Gray16 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtGray16BPC (x ,y ,_ecg .BytesPerLine ,_ecg .Data ,_ecg .Decode );
};func _dbeg (_ddcc *_ee .Gray ,_cagb uint8 )*_ee .Gray {_ebee :=_ddcc .Bounds ();_abbb :=_ee .NewGray (_ebee );for _cdab :=0;_cdab < _ebee .Dx ();_cdab ++{for _abff :=0;_abff < _ebee .Dy ();_abff ++{_cegc :=_ddcc .GrayAt (_cdab ,_abff );_abbb .SetGray (_cdab ,_abff ,_b .Gray {Y :_gdgg (_cegc .Y ,_cagb )});
};};return _abbb ;};func _gfcea (_fcf _b .CMYK )_b .NRGBA {_fgfc ,_aeee ,_bec :=_b .CMYKToRGB (_fcf .C ,_fcf .M ,_fcf .Y ,_fcf .K );return _b .NRGBA {R :_fgfc ,G :_aeee ,B :_bec ,A :0xff};};func (_ecfg *NRGBA16 )Base ()*ImageBase {return &_ecfg .ImageBase };
func (_dgaeg *NRGBA64 )setNRGBA64 (_aaea int ,_cfc _b .NRGBA64 ,_edae int ){_dgaeg .Data [_aaea ]=uint8 (_cfc .R >>8);_dgaeg .Data [_aaea +1]=uint8 (_cfc .R &0xff);_dgaeg .Data [_aaea +2]=uint8 (_cfc .G >>8);_dgaeg .Data [_aaea +3]=uint8 (_cfc .G &0xff);
_dgaeg .Data [_aaea +4]=uint8 (_cfc .B >>8);_dgaeg .Data [_aaea +5]=uint8 (_cfc .B &0xff);if _edae +1< len (_dgaeg .Alpha ){_dgaeg .Alpha [_edae ]=uint8 (_cfc .A >>8);_dgaeg .Alpha [_edae +1]=uint8 (_cfc .A &0xff);};};func (_ccfd *NRGBA32 )At (x ,y int )_b .Color {_egea ,_ :=_ccfd .ColorAt (x ,y );
return _egea };func NextPowerOf2 (n uint )uint {if IsPowerOf2 (n ){return n ;};return 1<<(_abcce (n )+1);};func GrayHistogram (g Gray )(_dfabf [256]int ){switch _cefa :=g .(type ){case Histogramer :return _cefa .Histogram ();case _ee .Image :_ecgc :=_cefa .Bounds ();
for _defeb :=0;_defeb < _ecgc .Max .X ;_defeb ++{for _dbff :=0;_dbff < _ecgc .Max .Y ;_dbff ++{_dfabf [g .GrayAt (_defeb ,_dbff ).Y ]++;};};return _dfabf ;default:return [256]int {};};};func (_egdd *CMYK32 )ColorModel ()_b .Model {return _b .CMYKModel };
func (_cfac *NRGBA32 )NRGBAAt (x ,y int )_b .NRGBA {_abdf ,_ :=ColorAtNRGBA32 (x ,y ,_cfac .Width ,_cfac .Data ,_cfac .Alpha ,_cfac .Decode );return _abdf ;};func (_ecdd *Gray16 )Set (x ,y int ,c _b .Color ){_egcf :=(y *_ecdd .BytesPerLine /2+x )*2;if _egcf +1>=len (_ecdd .Data ){return ;
};_ceec :=_b .Gray16Model .Convert (c ).(_b .Gray16 );_ecdd .Data [_egcf ],_ecdd .Data [_egcf +1]=uint8 (_ceec .Y >>8),uint8 (_ceec .Y &0xff);};func (_edd *Monochrome )InverseData ()error {return _edd .RasterOperation (0,0,_edd .Width ,_edd .Height ,PixNotDst ,nil ,0,0);
};func _feadc (_cdac *_ee .NYCbCrA ,_dfee NRGBA ,_bcgf _ee .Rectangle ){for _adfc :=0;_adfc < _bcgf .Max .X ;_adfc ++{for _bfgd :=0;_bfgd < _bcgf .Max .Y ;_bfgd ++{_eafe :=_cdac .NYCbCrAAt (_adfc ,_bfgd );_dfee .SetNRGBA (_adfc ,_bfgd ,_cff (_eafe ));};
};};func _adbb (_dega _ee .Image )(Image ,error ){if _bbff ,_cbdc :=_dega .(*Gray8 );_cbdc {return _bbff .Copy (),nil ;};_ccbbc :=_dega .Bounds ();_fggdg ,_dgab :=NewImage (_ccbbc .Max .X ,_ccbbc .Max .Y ,8,1,nil ,nil ,nil );if _dgab !=nil {return nil ,_dgab ;
};_aaba (_dega ,_fggdg ,_ccbbc );return _fggdg ,nil ;};func (_aca *monochromeThresholdConverter )Convert (img _ee .Image )(Image ,error ){if _ggg ,_ffbff :=img .(*Monochrome );_ffbff {return _ggg .Copy (),nil ;};_egce :=img .Bounds ();_egaa ,_bcdb :=NewImage (_egce .Max .X ,_egce .Max .Y ,1,1,nil ,nil ,nil );
if _bcdb !=nil {return nil ,_bcdb ;};_egaa .(*Monochrome ).ModelThreshold =_aca .Threshold ;for _acfg :=0;_acfg < _egce .Max .X ;_acfg ++{for _agbb :=0;_agbb < _egce .Max .Y ;_agbb ++{_dfbd :=img .At (_acfg ,_agbb );_egaa .Set (_acfg ,_agbb ,_dfbd );};
};return _egaa ,nil ;};func (_affb *NRGBA16 )NRGBAAt (x ,y int )_b .NRGBA {_fadc ,_ :=ColorAtNRGBA16 (x ,y ,_affb .Width ,_affb .BytesPerLine ,_affb .Data ,_affb .Alpha ,_affb .Decode );return _fadc ;};func (_cgfb *ImageBase )getByte (_cgb int )(byte ,error ){if _cgb > len (_cgfb .Data )-1||_cgb < 0{return 0,_ge .Errorf ("\u0069\u006e\u0064\u0065x:\u0020\u0025\u0064\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072\u0061\u006eg\u0065",_cgb );
};return _cgfb .Data [_cgb ],nil ;};func (_ceac *Gray16 )SetGray (x ,y int ,g _b .Gray ){_bdgc :=(y *_ceac .BytesPerLine /2+x )*2;if _bdgc +1>=len (_ceac .Data ){return ;};_ceac .Data [_bdgc ]=g .Y ;_ceac .Data [_bdgc +1]=g .Y ;};func _bgf (_ecdf _b .NRGBA )_b .RGBA {_cdd ,_fddg ,_afb ,_ccd :=_ecdf .RGBA ();
return _b .RGBA {R :uint8 (_cdd >>8),G :uint8 (_fddg >>8),B :uint8 (_afb >>8),A :uint8 (_ccd >>8)};};func _dbda (_egaf _b .Gray )_b .Gray {_dacd :=_egaf .Y >>6;_dacd |=_dacd <<2;_egaf .Y =_dacd |_dacd <<4;return _egaf ;};func (_aece *Gray4 )GrayAt (x ,y int )_b .Gray {_egefb ,_ :=ColorAtGray4BPC (x ,y ,_aece .BytesPerLine ,_aece .Data ,_aece .Decode );
return _egefb ;};func (_fgeb *CMYK32 )SetCMYK (x ,y int ,c _b .CMYK ){_acda :=4*(y *_fgeb .Width +x );if _acda +3>=len (_fgeb .Data ){return ;};_fgeb .Data [_acda ]=c .C ;_fgeb .Data [_acda +1]=c .M ;_fgeb .Data [_acda +2]=c .Y ;_fgeb .Data [_acda +3]=c .K ;
};func _aeag (_bgegg *_ee .Gray )bool {for _cfcd :=0;_cfcd < len (_bgegg .Pix );_cfcd ++{if !_adcag (_bgegg .Pix [_cfcd ]){return false ;};};return true ;};func (_bade *Gray16 )At (x ,y int )_b .Color {_ddf ,_ :=_bade .ColorAt (x ,y );return _ddf };func _ffd (_aee _b .NRGBA )_b .Gray {var _bbab _b .NRGBA ;
if _aee ==_bbab {return _b .Gray {Y :0xff};};_efe ,_gec ,_dcga ,_ :=_aee .RGBA ();_bcag :=(19595*_efe +38470*_gec +7471*_dcga +1<<15)>>24;return _b .Gray {Y :uint8 (_bcag )};};func (_gcdee *Monochrome )setBit (_dff ,_beaa int ){_gcdee .Data [_dff +(_beaa >>3)]|=0x80>>uint (_beaa &7);
};func _gffe (_gdab *Monochrome ,_dabd ,_baaf ,_bgeb ,_egaab int ,_deeb RasterOperator ,_edec *Monochrome ,_cbbc ,_ebf int )error {if _gdab ==nil {return _g .New ("\u006e\u0069\u006c\u0020\u0027\u0064\u0065\u0073\u0074\u0027\u0020\u0042i\u0074\u006d\u0061\u0070");
};if _deeb ==PixDst {return nil ;};switch _deeb {case PixClr ,PixSet ,PixNotDst :_deebf (_gdab ,_dabd ,_baaf ,_bgeb ,_egaab ,_deeb );return nil ;};if _edec ==nil {_d .Log .Debug ("\u0052a\u0073\u0074e\u0072\u004f\u0070\u0065r\u0061\u0074\u0069o\u006e\u0020\u0073\u006f\u0075\u0072\u0063\u0065\u0020bi\u0074\u006d\u0061p\u0020\u0069s\u0020\u006e\u006f\u0074\u0020\u0064e\u0066\u0069n\u0065\u0064");
return _g .New ("\u006e\u0069l\u0020\u0027\u0073r\u0063\u0027\u0020\u0062\u0069\u0074\u006d\u0061\u0070");};if _acb :=_edaae (_gdab ,_dabd ,_baaf ,_bgeb ,_egaab ,_deeb ,_edec ,_cbbc ,_ebf );_acb !=nil {return _acb ;};return nil ;};func (_fcfb *RGBA32 )ColorAt (x ,y int )(_b .Color ,error ){return ColorAtRGBA32 (x ,y ,_fcfb .Width ,_fcfb .Data ,_fcfb .Alpha ,_fcfb .Decode );
};func ColorAtGrayscale (x ,y ,bitsPerColor ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Color ,error ){switch bitsPerColor {case 1:return ColorAtGray1BPC (x ,y ,bytesPerLine ,data ,decode );case 2:return ColorAtGray2BPC (x ,y ,bytesPerLine ,data ,decode );
case 4:return ColorAtGray4BPC (x ,y ,bytesPerLine ,data ,decode );case 8:return ColorAtGray8BPC (x ,y ,bytesPerLine ,data ,decode );case 16:return ColorAtGray16BPC (x ,y ,bytesPerLine ,data ,decode );default:return nil ,_ge .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0067\u0072\u0061\u0079\u0020\u0073c\u0061\u006c\u0065\u0020\u0062\u0069\u0074s\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020a\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func _gddg (_gea _ee .Image )(Image ,error ){if _gfceaf ,_cgc :=_gea .(*Monochrome );_cgc {return _gfceaf ,nil ;};_gdce :=_gea .Bounds ();var _fead Gray ;switch _eacg :=_gea .(type ){case Gray :_fead =_eacg ;case NRGBA :_fead =&Gray8 {ImageBase :NewImageBase (_gdce .Max .X ,_gdce .Max .Y ,8,1,nil ,nil ,nil )};
_gead (_fead ,_eacg ,_gdce );case nrgba64 :_fead =&Gray8 {ImageBase :NewImageBase (_gdce .Max .X ,_gdce .Max .Y ,8,1,nil ,nil ,nil )};_cgfe (_fead ,_eacg ,_gdce );default:_efdb ,_bce :=GrayConverter .Convert (_gea );if _bce !=nil {return nil ,_bce ;};_fead =_efdb .(Gray );
};_aaff ,_agbe :=NewImage (_gdce .Max .X ,_gdce .Max .Y ,1,1,nil ,nil ,nil );if _agbe !=nil {return nil ,_agbe ;};_caa :=_aaff .(*Monochrome );_ggfbe :=AutoThresholdTriangle (GrayHistogram (_fead ));for _bae :=0;_bae < _gdce .Max .X ;_bae ++{for _egef :=0;
_egef < _gdce .Max .Y ;_egef ++{_caaf :=_cce (_fead .GrayAt (_bae ,_egef ),monochromeModel (_ggfbe ));_caa .SetGray (_bae ,_egef ,_caaf );};};return _aaff ,nil ;};func (_afba *ImageBase )MakeAlpha (){_afba .newAlpha ()};type NRGBA16 struct{ImageBase };
func (_ffag *CMYK32 )Validate ()error {if len (_ffag .Data )!=4*_ffag .Width *_ffag .Height {return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};func _eedf (_eagf nrgba64 ,_dgef NRGBA ,_dgad _ee .Rectangle ){for _gecag :=0;_gecag < _dgad .Max .X ;_gecag ++{for _dcda :=0;_dcda < _dgad .Max .Y ;_dcda ++{_eadb :=_eagf .NRGBA64At (_gecag ,_dcda );_dgef .SetNRGBA (_gecag ,_dcda ,_bffa (_eadb ));
};};};func _bddgc (_ebfa []byte ,_fggdc Image )error {_bedc :=true ;for _affa :=0;_affa < len (_ebfa );_affa ++{if _ebfa [_affa ]!=0xff{_bedc =false ;break ;};};if _bedc {switch _defa :=_fggdc .(type ){case *NRGBA32 :_defa .Alpha =nil ;case *NRGBA64 :_defa .Alpha =nil ;
default:return _ge .Errorf ("i\u006ete\u0072n\u0061l\u0020\u0065\u0072\u0072\u006fr\u0020\u002d\u0020i\u006d\u0061\u0067\u0065\u0020s\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070e\u0020\u002a\u004eRGB\u0041\u0033\u0032\u0020\u006f\u0072 \u002a\u004e\u0052\u0047\u0042\u0041\u0036\u0034\u0020\u0062\u0075\u0074 \u0069s\u003a\u0020\u0025\u0054",_fggdc );
};};return nil ;};func (_edaac *Monochrome )ResolveDecode ()error {if len (_edaac .Decode )!=2{return nil ;};if _edaac .Decode [0]==1&&_edaac .Decode [1]==0{if _agcg :=_edaac .InverseData ();_agcg !=nil {return _agcg ;};_edaac .Decode =nil ;};return nil ;
};func (_ffcf *Gray2 )Set (x ,y int ,c _b .Color ){if x >=_ffcf .Width ||y >=_ffcf .Height {return ;};_cbba :=Gray2Model .Convert (c ).(_b .Gray );_ccgd :=y *_ffcf .BytesPerLine ;_bagg :=_ccgd +(x >>2);_cbgd :=_cbba .Y >>6;_ffcf .Data [_bagg ]=(_ffcf .Data [_bagg ]&(^(0xc0>>uint (2*((x )&3)))))|(_cbgd <<uint (6-2*(x &3)));
};type Histogramer interface{Histogram ()[256]int ;};var _ _ee .Image =&NRGBA32 {};func _bed (_fdgg _ee .Image )(Image ,error ){if _ged ,_bcgc :=_fdgg .(*Gray4 );_bcgc {return _ged .Copy (),nil ;};_fbba :=_fdgg .Bounds ();_deaf ,_cefd :=NewImage (_fbba .Max .X ,_fbba .Max .Y ,4,1,nil ,nil ,nil );
if _cefd !=nil {return nil ,_cefd ;};_aaba (_fdgg ,_deaf ,_fbba );return _deaf ,nil ;};func BytesPerLine (width ,bitsPerComponent ,colorComponents int )int {return ((width *bitsPerComponent )*colorComponents +7)>>3;};func _caf (_ddcg _b .Color )_b .Color {_cfbd :=_b .GrayModel .Convert (_ddcg ).(_b .Gray );
return _efdf (_cfbd );};type NRGBA interface{NRGBAAt (_fbca ,_fgcc int )_b .NRGBA ;SetNRGBA (_cgcc ,_daea int ,_bacd _b .NRGBA );};var (_gedd =[]byte {0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF};_eafb =[]byte {0x00,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF};
);type Image interface{_f .Image ;Base ()*ImageBase ;Copy ()Image ;Pix ()[]byte ;ColorAt (_fbec ,_gddb int )(_b .Color ,error );Validate ()error ;};func (_acdd *RGBA32 )Bounds ()_ee .Rectangle {return _ee .Rectangle {Max :_ee .Point {X :_acdd .Width ,Y :_acdd .Height }};
};func NewImage (width ,height ,bitsPerComponent ,colorComponents int ,data ,alpha []byte ,decode []float64 )(Image ,error ){_fede :=NewImageBase (width ,height ,bitsPerComponent ,colorComponents ,data ,alpha ,decode );var _dfdde Image ;switch colorComponents {case 1:switch bitsPerComponent {case 1:_dfdde =&Monochrome {ImageBase :_fede ,ModelThreshold :0x0f};
case 2:_dfdde =&Gray2 {ImageBase :_fede };case 4:_dfdde =&Gray4 {ImageBase :_fede };case 8:_dfdde =&Gray8 {ImageBase :_fede };case 16:_dfdde =&Gray16 {ImageBase :_fede };};case 3:switch bitsPerComponent {case 4:_dfdde =&NRGBA16 {ImageBase :_fede };case 8:_dfdde =&NRGBA32 {ImageBase :_fede };
case 16:_dfdde =&NRGBA64 {ImageBase :_fede };};case 4:_dfdde =&CMYK32 {ImageBase :_fede };};if _dfdde ==nil {return nil ,ErrInvalidImage ;};return _dfdde ,nil ;};func _gacf (_adca *Monochrome ,_edbdd ,_geccg ,_cfdb ,_cbfe int ,_decd RasterOperator ,_ceecb *Monochrome ,_cdgdg ,_fgfa int )error {var (_ggfa byte ;
_aade int ;_ceeda int ;_aabf ,_gabf int ;_beec ,_gega int ;);_dgdd :=_cfdb >>3;_cbca :=_cfdb &7;if _cbca > 0{_ggfa =_gedd [_cbca ];};_aade =_ceecb .BytesPerLine *_fgfa +(_cdgdg >>3);_ceeda =_adca .BytesPerLine *_geccg +(_edbdd >>3);switch _decd {case PixSrc :for _beec =0;
_beec < _cbfe ;_beec ++{_aabf =_aade +_beec *_ceecb .BytesPerLine ;_gabf =_ceeda +_beec *_adca .BytesPerLine ;for _gega =0;_gega < _dgdd ;_gega ++{_adca .Data [_gabf ]=_ceecb .Data [_aabf ];_gabf ++;_aabf ++;};if _cbca > 0{_adca .Data [_gabf ]=_dabg (_adca .Data [_gabf ],_ceecb .Data [_aabf ],_ggfa );
};};case PixNotSrc :for _beec =0;_beec < _cbfe ;_beec ++{_aabf =_aade +_beec *_ceecb .BytesPerLine ;_gabf =_ceeda +_beec *_adca .BytesPerLine ;for _gega =0;_gega < _dgdd ;_gega ++{_adca .Data [_gabf ]=^(_ceecb .Data [_aabf ]);_gabf ++;_aabf ++;};if _cbca > 0{_adca .Data [_gabf ]=_dabg (_adca .Data [_gabf ],^_ceecb .Data [_aabf ],_ggfa );
};};case PixSrcOrDst :for _beec =0;_beec < _cbfe ;_beec ++{_aabf =_aade +_beec *_ceecb .BytesPerLine ;_gabf =_ceeda +_beec *_adca .BytesPerLine ;for _gega =0;_gega < _dgdd ;_gega ++{_adca .Data [_gabf ]|=_ceecb .Data [_aabf ];_gabf ++;_aabf ++;};if _cbca > 0{_adca .Data [_gabf ]=_dabg (_adca .Data [_gabf ],_ceecb .Data [_aabf ]|_adca .Data [_gabf ],_ggfa );
};};case PixSrcAndDst :for _beec =0;_beec < _cbfe ;_beec ++{_aabf =_aade +_beec *_ceecb .BytesPerLine ;_gabf =_ceeda +_beec *_adca .BytesPerLine ;for _gega =0;_gega < _dgdd ;_gega ++{_adca .Data [_gabf ]&=_ceecb .Data [_aabf ];_gabf ++;_aabf ++;};if _cbca > 0{_adca .Data [_gabf ]=_dabg (_adca .Data [_gabf ],_ceecb .Data [_aabf ]&_adca .Data [_gabf ],_ggfa );
};};case PixSrcXorDst :for _beec =0;_beec < _cbfe ;_beec ++{_aabf =_aade +_beec *_ceecb .BytesPerLine ;_gabf =_ceeda +_beec *_adca .BytesPerLine ;for _gega =0;_gega < _dgdd ;_gega ++{_adca .Data [_gabf ]^=_ceecb .Data [_aabf ];_gabf ++;_aabf ++;};if _cbca > 0{_adca .Data [_gabf ]=_dabg (_adca .Data [_gabf ],_ceecb .Data [_aabf ]^_adca .Data [_gabf ],_ggfa );
};};case PixNotSrcOrDst :for _beec =0;_beec < _cbfe ;_beec ++{_aabf =_aade +_beec *_ceecb .BytesPerLine ;_gabf =_ceeda +_beec *_adca .BytesPerLine ;for _gega =0;_gega < _dgdd ;_gega ++{_adca .Data [_gabf ]|=^(_ceecb .Data [_aabf ]);_gabf ++;_aabf ++;};
if _cbca > 0{_adca .Data [_gabf ]=_dabg (_adca .Data [_gabf ],^(_ceecb .Data [_aabf ])|_adca .Data [_gabf ],_ggfa );};};case PixNotSrcAndDst :for _beec =0;_beec < _cbfe ;_beec ++{_aabf =_aade +_beec *_ceecb .BytesPerLine ;_gabf =_ceeda +_beec *_adca .BytesPerLine ;
for _gega =0;_gega < _dgdd ;_gega ++{_adca .Data [_gabf ]&=^(_ceecb .Data [_aabf ]);_gabf ++;_aabf ++;};if _cbca > 0{_adca .Data [_gabf ]=_dabg (_adca .Data [_gabf ],^(_ceecb .Data [_aabf ])&_adca .Data [_gabf ],_ggfa );};};case PixSrcOrNotDst :for _beec =0;
_beec < _cbfe ;_beec ++{_aabf =_aade +_beec *_ceecb .BytesPerLine ;_gabf =_ceeda +_beec *_adca .BytesPerLine ;for _gega =0;_gega < _dgdd ;_gega ++{_adca .Data [_gabf ]=_ceecb .Data [_aabf ]|^(_adca .Data [_gabf ]);_gabf ++;_aabf ++;};if _cbca > 0{_adca .Data [_gabf ]=_dabg (_adca .Data [_gabf ],_ceecb .Data [_aabf ]|^(_adca .Data [_gabf ]),_ggfa );
};};case PixSrcAndNotDst :for _beec =0;_beec < _cbfe ;_beec ++{_aabf =_aade +_beec *_ceecb .BytesPerLine ;_gabf =_ceeda +_beec *_adca .BytesPerLine ;for _gega =0;_gega < _dgdd ;_gega ++{_adca .Data [_gabf ]=_ceecb .Data [_aabf ]&^(_adca .Data [_gabf ]);
_gabf ++;_aabf ++;};if _cbca > 0{_adca .Data [_gabf ]=_dabg (_adca .Data [_gabf ],_ceecb .Data [_aabf ]&^(_adca .Data [_gabf ]),_ggfa );};};case PixNotPixSrcOrDst :for _beec =0;_beec < _cbfe ;_beec ++{_aabf =_aade +_beec *_ceecb .BytesPerLine ;_gabf =_ceeda +_beec *_adca .BytesPerLine ;
for _gega =0;_gega < _dgdd ;_gega ++{_adca .Data [_gabf ]=^(_ceecb .Data [_aabf ]|_adca .Data [_gabf ]);_gabf ++;_aabf ++;};if _cbca > 0{_adca .Data [_gabf ]=_dabg (_adca .Data [_gabf ],^(_ceecb .Data [_aabf ]|_adca .Data [_gabf ]),_ggfa );};};case PixNotPixSrcAndDst :for _beec =0;
_beec < _cbfe ;_beec ++{_aabf =_aade +_beec *_ceecb .BytesPerLine ;_gabf =_ceeda +_beec *_adca .BytesPerLine ;for _gega =0;_gega < _dgdd ;_gega ++{_adca .Data [_gabf ]=^(_ceecb .Data [_aabf ]&_adca .Data [_gabf ]);_gabf ++;_aabf ++;};if _cbca > 0{_adca .Data [_gabf ]=_dabg (_adca .Data [_gabf ],^(_ceecb .Data [_aabf ]&_adca .Data [_gabf ]),_ggfa );
};};case PixNotPixSrcXorDst :for _beec =0;_beec < _cbfe ;_beec ++{_aabf =_aade +_beec *_ceecb .BytesPerLine ;_gabf =_ceeda +_beec *_adca .BytesPerLine ;for _gega =0;_gega < _dgdd ;_gega ++{_adca .Data [_gabf ]=^(_ceecb .Data [_aabf ]^_adca .Data [_gabf ]);
_gabf ++;_aabf ++;};if _cbca > 0{_adca .Data [_gabf ]=_dabg (_adca .Data [_gabf ],^(_ceecb .Data [_aabf ]^_adca .Data [_gabf ]),_ggfa );};};default:_d .Log .Debug ("\u0050\u0072ov\u0069\u0064\u0065d\u0020\u0069\u006e\u0076ali\u0064 r\u0061\u0073\u0074\u0065\u0072\u0020\u006fpe\u0072\u0061\u0074\u006f\u0072\u003a\u0020%\u0076",_decd );
return _g .New ("\u0069\u006e\u0076al\u0069\u0064\u0020\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u006f\u0072");};return nil ;};func (_fdc *Gray16 )Bounds ()_ee .Rectangle {return _ee .Rectangle {Max :_ee .Point {X :_fdc .Width ,Y :_fdc .Height }};
};func _bbec (_ccbe RGBA ,_bcec Gray ,_dbce _ee .Rectangle ){for _fegb :=0;_fegb < _dbce .Max .X ;_fegb ++{for _edbg :=0;_edbg < _dbce .Max .Y ;_edbg ++{_edba :=_cec (_ccbe .RGBAAt (_fegb ,_edbg ));_bcec .SetGray (_fegb ,_edbg ,_edba );};};};func _dfed (_badg *Monochrome ,_baea ,_gdga ,_cag ,_bdfe int ,_ccfg RasterOperator ,_bcfgb *Monochrome ,_dcc ,_deea int )error {var (_aace bool ;
_fdce bool ;_cgac byte ;_bfdf int ;_ffbc int ;_bfaa int ;_bdff int ;_fdgc bool ;_dcbf int ;_efbg int ;_baca int ;_dfaa bool ;_aae byte ;_bbafc int ;_fbbd int ;_bdec int ;_fffb byte ;_bcccb int ;_cgd int ;_adgg uint ;_bebb uint ;_egafd byte ;_dbfb shift ;
_ebdf bool ;_ddgg bool ;_gdcb ,_cefe int ;);if _dcc &7!=0{_cgd =8-(_dcc &7);};if _baea &7!=0{_ffbc =8-(_baea &7);};if _cgd ==0&&_ffbc ==0{_egafd =_eafb [0];}else {if _ffbc > _cgd {_adgg =uint (_ffbc -_cgd );}else {_adgg =uint (8-(_cgd -_ffbc ));};_bebb =8-_adgg ;
_egafd =_eafb [_adgg ];};if (_baea &7)!=0{_aace =true ;_bfdf =8-(_baea &7);_cgac =_eafb [_bfdf ];_bfaa =_badg .BytesPerLine *_gdga +(_baea >>3);_bdff =_bcfgb .BytesPerLine *_deea +(_dcc >>3);_bcccb =8-(_dcc &7);if _bfdf > _bcccb {_dbfb =_gagb ;if _cag >=_cgd {_ebdf =true ;
};}else {_dbfb =_dggg ;};};if _cag < _bfdf {_fdce =true ;_cgac &=_gedd [8-_bfdf +_cag ];};if !_fdce {_dcbf =(_cag -_bfdf )>>3;if _dcbf !=0{_fdgc =true ;_efbg =_badg .BytesPerLine *_gdga +((_baea +_ffbc )>>3);_baca =_bcfgb .BytesPerLine *_deea +((_dcc +_ffbc )>>3);
};};_bbafc =(_baea +_cag )&7;if !(_fdce ||_bbafc ==0){_dfaa =true ;_aae =_gedd [_bbafc ];_fbbd =_badg .BytesPerLine *_gdga +((_baea +_ffbc )>>3)+_dcbf ;_bdec =_bcfgb .BytesPerLine *_deea +((_dcc +_ffbc )>>3)+_dcbf ;if _bbafc > int (_bebb ){_ddgg =true ;
};};switch _ccfg {case PixSrc :if _aace {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{if _dbfb ==_gagb {_fffb =_bcfgb .Data [_bdff ]<<_adgg ;if _ebdf {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdff +1]>>_bebb ,_egafd );};}else {_fffb =_bcfgb .Data [_bdff ]>>_bebb ;};
_badg .Data [_bfaa ]=_dabg (_badg .Data [_bfaa ],_fffb ,_cgac );_bfaa +=_badg .BytesPerLine ;_bdff +=_bcfgb .BytesPerLine ;};};if _fdgc {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{for _cefe =0;_cefe < _dcbf ;_cefe ++{_fffb =_dabg (_bcfgb .Data [_baca +_cefe ]<<_adgg ,_bcfgb .Data [_baca +_cefe +1]>>_bebb ,_egafd );
_badg .Data [_efbg +_cefe ]=_fffb ;};_efbg +=_badg .BytesPerLine ;_baca +=_bcfgb .BytesPerLine ;};};if _dfaa {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{_fffb =_bcfgb .Data [_bdec ]<<_adgg ;if _ddgg {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdec +1]>>_bebb ,_egafd );
};_badg .Data [_fbbd ]=_dabg (_badg .Data [_fbbd ],_fffb ,_aae );_fbbd +=_badg .BytesPerLine ;_bdec +=_bcfgb .BytesPerLine ;};};case PixNotSrc :if _aace {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{if _dbfb ==_gagb {_fffb =_bcfgb .Data [_bdff ]<<_adgg ;if _ebdf {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdff +1]>>_bebb ,_egafd );
};}else {_fffb =_bcfgb .Data [_bdff ]>>_bebb ;};_badg .Data [_bfaa ]=_dabg (_badg .Data [_bfaa ],^_fffb ,_cgac );_bfaa +=_badg .BytesPerLine ;_bdff +=_bcfgb .BytesPerLine ;};};if _fdgc {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{for _cefe =0;_cefe < _dcbf ;_cefe ++{_fffb =_dabg (_bcfgb .Data [_baca +_cefe ]<<_adgg ,_bcfgb .Data [_baca +_cefe +1]>>_bebb ,_egafd );
_badg .Data [_efbg +_cefe ]=^_fffb ;};_efbg +=_badg .BytesPerLine ;_baca +=_bcfgb .BytesPerLine ;};};if _dfaa {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{_fffb =_bcfgb .Data [_bdec ]<<_adgg ;if _ddgg {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdec +1]>>_bebb ,_egafd );
};_badg .Data [_fbbd ]=_dabg (_badg .Data [_fbbd ],^_fffb ,_aae );_fbbd +=_badg .BytesPerLine ;_bdec +=_bcfgb .BytesPerLine ;};};case PixSrcOrDst :if _aace {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{if _dbfb ==_gagb {_fffb =_bcfgb .Data [_bdff ]<<_adgg ;if _ebdf {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdff +1]>>_bebb ,_egafd );
};}else {_fffb =_bcfgb .Data [_bdff ]>>_bebb ;};_badg .Data [_bfaa ]=_dabg (_badg .Data [_bfaa ],_fffb |_badg .Data [_bfaa ],_cgac );_bfaa +=_badg .BytesPerLine ;_bdff +=_bcfgb .BytesPerLine ;};};if _fdgc {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{for _cefe =0;
_cefe < _dcbf ;_cefe ++{_fffb =_dabg (_bcfgb .Data [_baca +_cefe ]<<_adgg ,_bcfgb .Data [_baca +_cefe +1]>>_bebb ,_egafd );_badg .Data [_efbg +_cefe ]|=_fffb ;};_efbg +=_badg .BytesPerLine ;_baca +=_bcfgb .BytesPerLine ;};};if _dfaa {for _gdcb =0;_gdcb < _bdfe ;
_gdcb ++{_fffb =_bcfgb .Data [_bdec ]<<_adgg ;if _ddgg {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdec +1]>>_bebb ,_egafd );};_badg .Data [_fbbd ]=_dabg (_badg .Data [_fbbd ],_fffb |_badg .Data [_fbbd ],_aae );_fbbd +=_badg .BytesPerLine ;_bdec +=_bcfgb .BytesPerLine ;
};};case PixSrcAndDst :if _aace {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{if _dbfb ==_gagb {_fffb =_bcfgb .Data [_bdff ]<<_adgg ;if _ebdf {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdff +1]>>_bebb ,_egafd );};}else {_fffb =_bcfgb .Data [_bdff ]>>_bebb ;};_badg .Data [_bfaa ]=_dabg (_badg .Data [_bfaa ],_fffb &_badg .Data [_bfaa ],_cgac );
_bfaa +=_badg .BytesPerLine ;_bdff +=_bcfgb .BytesPerLine ;};};if _fdgc {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{for _cefe =0;_cefe < _dcbf ;_cefe ++{_fffb =_dabg (_bcfgb .Data [_baca +_cefe ]<<_adgg ,_bcfgb .Data [_baca +_cefe +1]>>_bebb ,_egafd );_badg .Data [_efbg +_cefe ]&=_fffb ;
};_efbg +=_badg .BytesPerLine ;_baca +=_bcfgb .BytesPerLine ;};};if _dfaa {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{_fffb =_bcfgb .Data [_bdec ]<<_adgg ;if _ddgg {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdec +1]>>_bebb ,_egafd );};_badg .Data [_fbbd ]=_dabg (_badg .Data [_fbbd ],_fffb &_badg .Data [_fbbd ],_aae );
_fbbd +=_badg .BytesPerLine ;_bdec +=_bcfgb .BytesPerLine ;};};case PixSrcXorDst :if _aace {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{if _dbfb ==_gagb {_fffb =_bcfgb .Data [_bdff ]<<_adgg ;if _ebdf {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdff +1]>>_bebb ,_egafd );
};}else {_fffb =_bcfgb .Data [_bdff ]>>_bebb ;};_badg .Data [_bfaa ]=_dabg (_badg .Data [_bfaa ],_fffb ^_badg .Data [_bfaa ],_cgac );_bfaa +=_badg .BytesPerLine ;_bdff +=_bcfgb .BytesPerLine ;};};if _fdgc {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{for _cefe =0;
_cefe < _dcbf ;_cefe ++{_fffb =_dabg (_bcfgb .Data [_baca +_cefe ]<<_adgg ,_bcfgb .Data [_baca +_cefe +1]>>_bebb ,_egafd );_badg .Data [_efbg +_cefe ]^=_fffb ;};_efbg +=_badg .BytesPerLine ;_baca +=_bcfgb .BytesPerLine ;};};if _dfaa {for _gdcb =0;_gdcb < _bdfe ;
_gdcb ++{_fffb =_bcfgb .Data [_bdec ]<<_adgg ;if _ddgg {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdec +1]>>_bebb ,_egafd );};_badg .Data [_fbbd ]=_dabg (_badg .Data [_fbbd ],_fffb ^_badg .Data [_fbbd ],_aae );_fbbd +=_badg .BytesPerLine ;_bdec +=_bcfgb .BytesPerLine ;
};};case PixNotSrcOrDst :if _aace {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{if _dbfb ==_gagb {_fffb =_bcfgb .Data [_bdff ]<<_adgg ;if _ebdf {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdff +1]>>_bebb ,_egafd );};}else {_fffb =_bcfgb .Data [_bdff ]>>_bebb ;};_badg .Data [_bfaa ]=_dabg (_badg .Data [_bfaa ],^_fffb |_badg .Data [_bfaa ],_cgac );
_bfaa +=_badg .BytesPerLine ;_bdff +=_bcfgb .BytesPerLine ;};};if _fdgc {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{for _cefe =0;_cefe < _dcbf ;_cefe ++{_fffb =_dabg (_bcfgb .Data [_baca +_cefe ]<<_adgg ,_bcfgb .Data [_baca +_cefe +1]>>_bebb ,_egafd );_badg .Data [_efbg +_cefe ]|=^_fffb ;
};_efbg +=_badg .BytesPerLine ;_baca +=_bcfgb .BytesPerLine ;};};if _dfaa {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{_fffb =_bcfgb .Data [_bdec ]<<_adgg ;if _ddgg {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdec +1]>>_bebb ,_egafd );};_badg .Data [_fbbd ]=_dabg (_badg .Data [_fbbd ],^_fffb |_badg .Data [_fbbd ],_aae );
_fbbd +=_badg .BytesPerLine ;_bdec +=_bcfgb .BytesPerLine ;};};case PixNotSrcAndDst :if _aace {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{if _dbfb ==_gagb {_fffb =_bcfgb .Data [_bdff ]<<_adgg ;if _ebdf {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdff +1]>>_bebb ,_egafd );
};}else {_fffb =_bcfgb .Data [_bdff ]>>_bebb ;};_badg .Data [_bfaa ]=_dabg (_badg .Data [_bfaa ],^_fffb &_badg .Data [_bfaa ],_cgac );_bfaa +=_badg .BytesPerLine ;_bdff +=_bcfgb .BytesPerLine ;};};if _fdgc {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{for _cefe =0;
_cefe < _dcbf ;_cefe ++{_fffb =_dabg (_bcfgb .Data [_baca +_cefe ]<<_adgg ,_bcfgb .Data [_baca +_cefe +1]>>_bebb ,_egafd );_badg .Data [_efbg +_cefe ]&=^_fffb ;};_efbg +=_badg .BytesPerLine ;_baca +=_bcfgb .BytesPerLine ;};};if _dfaa {for _gdcb =0;_gdcb < _bdfe ;
_gdcb ++{_fffb =_bcfgb .Data [_bdec ]<<_adgg ;if _ddgg {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdec +1]>>_bebb ,_egafd );};_badg .Data [_fbbd ]=_dabg (_badg .Data [_fbbd ],^_fffb &_badg .Data [_fbbd ],_aae );_fbbd +=_badg .BytesPerLine ;_bdec +=_bcfgb .BytesPerLine ;
};};case PixSrcOrNotDst :if _aace {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{if _dbfb ==_gagb {_fffb =_bcfgb .Data [_bdff ]<<_adgg ;if _ebdf {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdff +1]>>_bebb ,_egafd );};}else {_fffb =_bcfgb .Data [_bdff ]>>_bebb ;};_badg .Data [_bfaa ]=_dabg (_badg .Data [_bfaa ],_fffb |^_badg .Data [_bfaa ],_cgac );
_bfaa +=_badg .BytesPerLine ;_bdff +=_bcfgb .BytesPerLine ;};};if _fdgc {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{for _cefe =0;_cefe < _dcbf ;_cefe ++{_fffb =_dabg (_bcfgb .Data [_baca +_cefe ]<<_adgg ,_bcfgb .Data [_baca +_cefe +1]>>_bebb ,_egafd );_badg .Data [_efbg +_cefe ]=_fffb |^_badg .Data [_efbg +_cefe ];
};_efbg +=_badg .BytesPerLine ;_baca +=_bcfgb .BytesPerLine ;};};if _dfaa {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{_fffb =_bcfgb .Data [_bdec ]<<_adgg ;if _ddgg {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdec +1]>>_bebb ,_egafd );};_badg .Data [_fbbd ]=_dabg (_badg .Data [_fbbd ],_fffb |^_badg .Data [_fbbd ],_aae );
_fbbd +=_badg .BytesPerLine ;_bdec +=_bcfgb .BytesPerLine ;};};case PixSrcAndNotDst :if _aace {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{if _dbfb ==_gagb {_fffb =_bcfgb .Data [_bdff ]<<_adgg ;if _ebdf {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdff +1]>>_bebb ,_egafd );
};}else {_fffb =_bcfgb .Data [_bdff ]>>_bebb ;};_badg .Data [_bfaa ]=_dabg (_badg .Data [_bfaa ],_fffb &^_badg .Data [_bfaa ],_cgac );_bfaa +=_badg .BytesPerLine ;_bdff +=_bcfgb .BytesPerLine ;};};if _fdgc {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{for _cefe =0;
_cefe < _dcbf ;_cefe ++{_fffb =_dabg (_bcfgb .Data [_baca +_cefe ]<<_adgg ,_bcfgb .Data [_baca +_cefe +1]>>_bebb ,_egafd );_badg .Data [_efbg +_cefe ]=_fffb &^_badg .Data [_efbg +_cefe ];};_efbg +=_badg .BytesPerLine ;_baca +=_bcfgb .BytesPerLine ;};};
if _dfaa {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{_fffb =_bcfgb .Data [_bdec ]<<_adgg ;if _ddgg {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdec +1]>>_bebb ,_egafd );};_badg .Data [_fbbd ]=_dabg (_badg .Data [_fbbd ],_fffb &^_badg .Data [_fbbd ],_aae );_fbbd +=_badg .BytesPerLine ;
_bdec +=_bcfgb .BytesPerLine ;};};case PixNotPixSrcOrDst :if _aace {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{if _dbfb ==_gagb {_fffb =_bcfgb .Data [_bdff ]<<_adgg ;if _ebdf {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdff +1]>>_bebb ,_egafd );};}else {_fffb =_bcfgb .Data [_bdff ]>>_bebb ;
};_badg .Data [_bfaa ]=_dabg (_badg .Data [_bfaa ],^(_fffb |_badg .Data [_bfaa ]),_cgac );_bfaa +=_badg .BytesPerLine ;_bdff +=_bcfgb .BytesPerLine ;};};if _fdgc {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{for _cefe =0;_cefe < _dcbf ;_cefe ++{_fffb =_dabg (_bcfgb .Data [_baca +_cefe ]<<_adgg ,_bcfgb .Data [_baca +_cefe +1]>>_bebb ,_egafd );
_badg .Data [_efbg +_cefe ]=^(_fffb |_badg .Data [_efbg +_cefe ]);};_efbg +=_badg .BytesPerLine ;_baca +=_bcfgb .BytesPerLine ;};};if _dfaa {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{_fffb =_bcfgb .Data [_bdec ]<<_adgg ;if _ddgg {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdec +1]>>_bebb ,_egafd );
};_badg .Data [_fbbd ]=_dabg (_badg .Data [_fbbd ],^(_fffb |_badg .Data [_fbbd ]),_aae );_fbbd +=_badg .BytesPerLine ;_bdec +=_bcfgb .BytesPerLine ;};};case PixNotPixSrcAndDst :if _aace {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{if _dbfb ==_gagb {_fffb =_bcfgb .Data [_bdff ]<<_adgg ;
if _ebdf {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdff +1]>>_bebb ,_egafd );};}else {_fffb =_bcfgb .Data [_bdff ]>>_bebb ;};_badg .Data [_bfaa ]=_dabg (_badg .Data [_bfaa ],^(_fffb &_badg .Data [_bfaa ]),_cgac );_bfaa +=_badg .BytesPerLine ;_bdff +=_bcfgb .BytesPerLine ;
};};if _fdgc {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{for _cefe =0;_cefe < _dcbf ;_cefe ++{_fffb =_dabg (_bcfgb .Data [_baca +_cefe ]<<_adgg ,_bcfgb .Data [_baca +_cefe +1]>>_bebb ,_egafd );_badg .Data [_efbg +_cefe ]=^(_fffb &_badg .Data [_efbg +_cefe ]);
};_efbg +=_badg .BytesPerLine ;_baca +=_bcfgb .BytesPerLine ;};};if _dfaa {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{_fffb =_bcfgb .Data [_bdec ]<<_adgg ;if _ddgg {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdec +1]>>_bebb ,_egafd );};_badg .Data [_fbbd ]=_dabg (_badg .Data [_fbbd ],^(_fffb &_badg .Data [_fbbd ]),_aae );
_fbbd +=_badg .BytesPerLine ;_bdec +=_bcfgb .BytesPerLine ;};};case PixNotPixSrcXorDst :if _aace {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{if _dbfb ==_gagb {_fffb =_bcfgb .Data [_bdff ]<<_adgg ;if _ebdf {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdff +1]>>_bebb ,_egafd );
};}else {_fffb =_bcfgb .Data [_bdff ]>>_bebb ;};_badg .Data [_bfaa ]=_dabg (_badg .Data [_bfaa ],^(_fffb ^_badg .Data [_bfaa ]),_cgac );_bfaa +=_badg .BytesPerLine ;_bdff +=_bcfgb .BytesPerLine ;};};if _fdgc {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{for _cefe =0;
_cefe < _dcbf ;_cefe ++{_fffb =_dabg (_bcfgb .Data [_baca +_cefe ]<<_adgg ,_bcfgb .Data [_baca +_cefe +1]>>_bebb ,_egafd );_badg .Data [_efbg +_cefe ]=^(_fffb ^_badg .Data [_efbg +_cefe ]);};_efbg +=_badg .BytesPerLine ;_baca +=_bcfgb .BytesPerLine ;};
};if _dfaa {for _gdcb =0;_gdcb < _bdfe ;_gdcb ++{_fffb =_bcfgb .Data [_bdec ]<<_adgg ;if _ddgg {_fffb =_dabg (_fffb ,_bcfgb .Data [_bdec +1]>>_bebb ,_egafd );};_badg .Data [_fbbd ]=_dabg (_badg .Data [_fbbd ],^(_fffb ^_badg .Data [_fbbd ]),_aae );_fbbd +=_badg .BytesPerLine ;
_bdec +=_bcfgb .BytesPerLine ;};};default:_d .Log .Debug ("\u004f\u0070e\u0072\u0061\u0074\u0069\u006f\u006e\u003a\u0020\u0027\u0025\u0064\u0027\u0020\u006e\u006f\u0074\u0020\u0070\u0065\u0072\u006d\u0069tt\u0065\u0064",_ccfg );return _g .New ("\u0072\u0061\u0073\u0074\u0065\u0072\u0020\u006f\u0070\u0065r\u0061\u0074\u0069\u006f\u006e\u0020\u006eo\u0074\u0020\u0070\u0065\u0072\u006d\u0069\u0074\u0074\u0065\u0064");
};return nil ;};func (_baee *NRGBA16 )Validate ()error {if len (_baee .Data )!=3*_baee .Width *_baee .Height /2{return _g .New ("i\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0069\u006da\u0067\u0065\u0020\u0064\u0061\u0074\u0061 s\u0069\u007a\u0065\u0020f\u006f\u0072\u0020\u0070\u0072\u006f\u0076\u0069\u0064ed\u0020\u0064i\u006d\u0065\u006e\u0073\u0069\u006f\u006e\u0073");
};return nil ;};type RasterOperator int ;func _cgf (_cdg _b .NYCbCrA )_b .RGBA {_degb ,_bfc ,_fga ,_gefa :=_cff (_cdg ).RGBA ();return _b .RGBA {R :uint8 (_degb >>8),G :uint8 (_bfc >>8),B :uint8 (_fga >>8),A :uint8 (_gefa >>8)};};func (_fcff *Monochrome )clearBit (_beef ,_afdd int ){_fcff .Data [_beef ]&=^(0x80>>uint (_afdd &7))};
var _ Image =&NRGBA32 {};func (_cebf *ImageBase )setEightFullBytes (_edad int ,_fece uint64 )error {if _edad +7> len (_cebf .Data )-1{return _g .New ("\u0069n\u0064e\u0078\u0020\u006f\u0075\u0074 \u006f\u0066 \u0072\u0061\u006e\u0067\u0065");};_cebf .Data [_edad ]=byte ((_fece &0xff00000000000000)>>56);
_cebf .Data [_edad +1]=byte ((_fece &0xff000000000000)>>48);_cebf .Data [_edad +2]=byte ((_fece &0xff0000000000)>>40);_cebf .Data [_edad +3]=byte ((_fece &0xff00000000)>>32);_cebf .Data [_edad +4]=byte ((_fece &0xff000000)>>24);_cebf .Data [_edad +5]=byte ((_fece &0xff0000)>>16);
_cebf .Data [_edad +6]=byte ((_fece &0xff00)>>8);_cebf .Data [_edad +7]=byte (_fece &0xff);return nil ;};func _beb (_gaf ,_abga *Monochrome )(_eb error ){_ag :=_abga .BytesPerLine ;_abb :=_gaf .BytesPerLine ;var (_gba byte ;_bb uint16 ;_egd ,_abba ,_bbe ,_dc ,_ed int ;
);for _bbe =0;_bbe < _abga .Height ;_bbe ++{_egd =_bbe *_ag ;_abba =2*_bbe *_abb ;for _dc =0;_dc < _ag ;_dc ++{_gba =_abga .Data [_egd +_dc ];_bb =_ec [_gba ];_ed =_abba +_dc *2;if _gaf .BytesPerLine !=_abga .BytesPerLine *2&&(_dc +1)*2> _gaf .BytesPerLine {_eb =_gaf .setByte (_ed ,byte (_bb >>8));
}else {_eb =_gaf .setTwoBytes (_ed ,_bb );};if _eb !=nil {return _eb ;};};for _dc =0;_dc < _abb ;_dc ++{_ed =_abba +_abb +_dc ;_gba =_gaf .Data [_abba +_dc ];if _eb =_gaf .setByte (_ed ,_gba );_eb !=nil {return _eb ;};};};return nil ;};func (_gebf *RGBA32 )At (x ,y int )_b .Color {_ffaf ,_ :=_gebf .ColorAt (x ,y );
return _ffaf };func _dabg (_fccb ,_dbea ,_dbagg byte )byte {return (_fccb &^(_dbagg ))|(_dbea &_dbagg )};func _fdaf (_bfdaf ,_adbc RGBA ,_fbafb _ee .Rectangle ){for _abbc :=0;_abbc < _fbafb .Max .X ;_abbc ++{for _afdf :=0;_afdf < _fbafb .Max .Y ;_afdf ++{_adbc .SetRGBA (_abbc ,_afdf ,_bfdaf .RGBAAt (_abbc ,_afdf ));
};};};func _aceg (_bgd _b .CMYK )_b .Gray {_bgg ,_fcg ,_bda :=_b .CMYKToRGB (_bgd .C ,_bgd .M ,_bgd .Y ,_bgd .K );_gcde :=(19595*uint32 (_bgg )+38470*uint32 (_fcg )+7471*uint32 (_bda )+1<<7)>>16;return _b .Gray {Y :uint8 (_gcde )};};func (_eecd *Gray8 )ColorModel ()_b .Model {return _b .GrayModel };
func _gacg (_dfb RGBA ,_deb CMYK ,_cabe _ee .Rectangle ){for _egbg :=0;_egbg < _cabe .Max .X ;_egbg ++{for _affe :=0;_affe < _cabe .Max .Y ;_affe ++{_ebgc :=_dfb .RGBAAt (_egbg ,_affe );_deb .SetCMYK (_egbg ,_affe ,_dee (_ebgc ));};};};func _ggdb (_adece NRGBA ,_fbfg RGBA ,_eddd _ee .Rectangle ){for _cfbe :=0;
_cfbe < _eddd .Max .X ;_cfbe ++{for _afbg :=0;_afbg < _eddd .Max .Y ;_afbg ++{_ecafb :=_adece .NRGBAAt (_cfbe ,_afbg );_fbfg .SetRGBA (_cfbe ,_afbg ,_bgf (_ecafb ));};};};func ColorAtRGBA32 (x ,y ,width int ,data ,alpha []byte ,decode []float64 )(_b .RGBA ,error ){_dbfdb :=y *width +x ;
_egac :=3*_dbfdb ;if _egac +2>=len (data ){return _b .RGBA {},_ge .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_dffa :=uint8 (0xff);if alpha !=nil &&len (alpha )> _dbfdb {_dffa =alpha [_dbfdb ];};_fbac ,_egafg ,_fgfcg :=data [_egac ],data [_egac +1],data [_egac +2];if len (decode )==6{_fbac =uint8 (uint32 (LinearInterpolate (float64 (_fbac ),0,255,decode [0],decode [1]))&0xff);
_egafg =uint8 (uint32 (LinearInterpolate (float64 (_egafg ),0,255,decode [2],decode [3]))&0xff);_fgfcg =uint8 (uint32 (LinearInterpolate (float64 (_fgfcg ),0,255,decode [4],decode [5]))&0xff);};return _b .RGBA {R :_fbac ,G :_egafg ,B :_fgfcg ,A :_dffa },nil ;
};func (_gdad *NRGBA16 )Bounds ()_ee .Rectangle {return _ee .Rectangle {Max :_ee .Point {X :_gdad .Width ,Y :_gdad .Height }};};func MonochromeThresholdConverter (threshold uint8 )ColorConverter {return &monochromeThresholdConverter {Threshold :threshold };
};type NRGBA32 struct{ImageBase };func (_fbcb *ImageBase )setEightBytes (_agf int ,_bdgcd uint64 )error {_eeea :=_fbcb .BytesPerLine -(_agf %_fbcb .BytesPerLine );if _fbcb .BytesPerLine !=_fbcb .Width >>3{_eeea --;};if _eeea >=8{return _fbcb .setEightFullBytes (_agf ,_bdgcd );
};return _fbcb .setEightPartlyBytes (_agf ,_eeea ,_bdgcd );};func _feb ()(_adg []byte ){_adg =make ([]byte ,256);for _dfgb :=0;_dfgb < 256;_dfgb ++{_ffa :=byte (_dfgb );_adg [_ffa ]=(_ffa &0x01)|((_ffa &0x04)>>1)|((_ffa &0x10)>>2)|((_ffa &0x40)>>3)|((_ffa &0x02)<<3)|((_ffa &0x08)<<2)|((_ffa &0x20)<<1)|(_ffa &0x80);
};return _adg ;};func (_bbee *Gray2 )Validate ()error {if len (_bbee .Data )!=_bbee .Height *_bbee .BytesPerLine {return ErrInvalidImage ;};return nil ;};func _eadd (_cabea Gray ,_gdca RGBA ,_gbdgb _ee .Rectangle ){for _egdde :=0;_egdde < _gbdgb .Max .X ;
_egdde ++{for _gecdc :=0;_gecdc < _gbdgb .Max .Y ;_gecdc ++{_dadg :=_cabea .GrayAt (_egdde ,_gecdc );_gdca .SetRGBA (_egdde ,_gecdc ,_eaae (_dadg ));};};};var _ RGBA =&RGBA32 {};func (_eeab *NRGBA32 )Base ()*ImageBase {return &_eeab .ImageBase };func _egcbd (_eeff Gray ,_bcee NRGBA ,_facc _ee .Rectangle ){for _fffad :=0;
_fffad < _facc .Max .X ;_fffad ++{for _gged :=0;_gged < _facc .Max .Y ;_gged ++{_cfgbe :=_eeff .GrayAt (_fffad ,_gged );_bcee .SetNRGBA (_fffad ,_gged ,_fdad (_cfgbe ));};};};func (_bga *Monochrome )getBit (_ccf ,_edgeb int )uint8 {return _bga .Data [_ccf +(_edgeb >>3)]>>uint (7-(_edgeb &7))&1;
};func _bca (_dgb int )[]uint {var _bcg []uint ;_gbg :=_dgb ;_eadg :=_gbg /8;if _eadg !=0{for _gbb :=0;_gbb < _eadg ;_gbb ++{_bcg =append (_bcg ,8);};_cd :=_gbg %8;_gbg =0;if _cd !=0{_gbg =_cd ;};};_cee :=_gbg /4;if _cee !=0{for _dbg :=0;_dbg < _cee ;_dbg ++{_bcg =append (_bcg ,4);
};_gg :=_gbg %4;_gbg =0;if _gg !=0{_gbg =_gg ;};};_gfad :=_gbg /2;if _gfad !=0{for _cdc :=0;_cdc < _gfad ;_cdc ++{_bcg =append (_bcg ,2);};};return _bcg ;};func _fdfb (_eebd int ,_fgdg int )error {return _ge .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",_eebd ,_fgdg );
};func _cce (_cfa _b .Gray ,_bagc monochromeModel )_b .Gray {if _cfa .Y > uint8 (_bagc ){return _b .Gray {Y :_a .MaxUint8 };};return _b .Gray {};};func _ececb (_bgaf ,_efbgb NRGBA ,_fbaa _ee .Rectangle ){for _dbca :=0;_dbca < _fbaa .Max .X ;_dbca ++{for _dbeae :=0;
_dbeae < _fbaa .Max .Y ;_dbeae ++{_efbgb .SetNRGBA (_dbca ,_dbeae ,_bgaf .NRGBAAt (_dbca ,_dbeae ));};};};func ColorAtGray1BPC (x ,y ,bytesPerLine int ,data []byte ,decode []float64 )(_b .Gray ,error ){_acef :=y *bytesPerLine +x >>3;if _acef >=len (data ){return _b .Gray {},_ge .Errorf ("\u0069\u006d\u0061\u0067\u0065\u0020\u0063\u006f\u006f\u0072\u0064\u0069\u006ea\u0074\u0065\u0073\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0028\u0025\u0064,\u0020\u0025\u0064\u0029",x ,y );
};_agdg :=data [_acef ]>>uint (7-(x &7))&1;if len (decode )==2{_agdg =uint8 (LinearInterpolate (float64 (_agdg ),0.0,1.0,decode [0],decode [1]))&1;};return _b .Gray {Y :_agdg *255},nil ;};var _ Image =&Monochrome {};func (_egca *Monochrome )Bounds ()_ee .Rectangle {return _ee .Rectangle {Max :_ee .Point {X :_egca .Width ,Y :_egca .Height }};
};func _bffa (_fde _b .NRGBA64 )_b .NRGBA {return _b .NRGBA {R :uint8 (_fde .R >>8),G :uint8 (_fde .G >>8),B :uint8 (_fde .B >>8),A :uint8 (_fde .A >>8)};};const (_gagb shift =iota ;_dggg ;);func AddDataPadding (width ,height ,bitsPerComponent ,colorComponents int ,data []byte )([]byte ,error ){_eeae :=BytesPerLine (width ,bitsPerComponent ,colorComponents );
if _eeae ==width *colorComponents *bitsPerComponent /8{return data ,nil ;};_gffd :=width *colorComponents *bitsPerComponent ;_bdb :=_eeae *8;_dcb :=8-(_bdb -_gffd );_cdfg :=_ff .NewReader (data );_cfd :=_eeae -1;_gegf :=make ([]byte ,_cfd );_dfgg :=make ([]byte ,height *_eeae );
_cdca :=_ff .NewWriterMSB (_dfgg );var _fdfac uint64 ;var _afca error ;for _bdab :=0;_bdab < height ;_bdab ++{_ ,_afca =_cdfg .Read (_gegf );if _afca !=nil {return nil ,_afca ;};_ ,_afca =_cdca .Write (_gegf );if _afca !=nil {return nil ,_afca ;};_fdfac ,_afca =_cdfg .ReadBits (byte (_dcb ));
if _afca !=nil {return nil ,_afca ;};_ ,_afca =_cdca .WriteBits (_fdfac ,_dcb );if _afca !=nil {return nil ,_afca ;};_cdca .FinishByte ();};return _dfgg ,nil ;};type Gray16 struct{ImageBase };func ColorAtNRGBA (x ,y ,width ,bytesPerLine ,bitsPerColor int ,data ,alpha []byte ,decode []float64 )(_b .Color ,error ){switch bitsPerColor {case 4:return ColorAtNRGBA16 (x ,y ,width ,bytesPerLine ,data ,alpha ,decode );
case 8:return ColorAtNRGBA32 (x ,y ,width ,data ,alpha ,decode );case 16:return ColorAtNRGBA64 (x ,y ,width ,data ,alpha ,decode );default:return nil ,_ge .Errorf ("\u0075\u006e\u0073\u0075\u0070\u0070\u006fr\u0074\u0065\u0064 \u0072\u0067\u0062\u0020b\u0069\u0074\u0073\u0020\u0070\u0065\u0072\u0020\u0063\u006f\u006c\u006f\u0072\u0020\u0061\u006d\u006f\u0075\u006e\u0074\u003a\u0020\u0027\u0025\u0064\u0027",bitsPerColor );
};};func _fbcbd (_bcbc *_ee .Gray16 ,_adbf uint8 )*_ee .Gray {_cfce :=_bcbc .Bounds ();_bbb :=_ee .NewGray (_cfce );for _ggcb :=0;_ggcb < _cfce .Dx ();_ggcb ++{for _ggdee :=0;_ggdee < _cfce .Dy ();_ggdee ++{_agaf :=_bcbc .Gray16At (_ggcb ,_ggdee );_bbb .SetGray (_ggcb ,_ggdee ,_b .Gray {Y :_gdgg (uint8 (_agaf .Y /256),_adbf )});
};};return _bbb ;};